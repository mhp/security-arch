<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>WebRTC Security Architecture</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
      /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
      a.info {
          /* This is the key. */
          position: relative;
          z-index: 24;
          text-decoration: none;
      }
      a.info:hover {
          z-index: 25;
          color: #FFF; background-color: #900;
      }
      a.info span { display: none; }
      a.info:hover span.info {
          /* The span will display just on :hover state. */
          display: block;
          position: absolute;
          font-size: smaller;
          top: 2em; left: -5em; width: 15em;
          padding: 2px; border: 1px solid #333;
          color: #900; background-color: #EEE;
          text-align: left;
      }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  max-width: 55em;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents"/>
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction"/>
<link href="#rfc.section.2" rel="Chapter" title="2 Terminology"/>
<link href="#rfc.section.3" rel="Chapter" title="3 Trust Model"/>
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Authenticated Entities"/>
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Unauthenticated Entities"/>
<link href="#rfc.section.4" rel="Chapter" title="4 Overview"/>
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Initial Signaling"/>
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Media Consent Verification"/>
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 DTLS Handshake"/>
<link href="#rfc.section.4.4" rel="Chapter" title="4.4 Communications and Consent Freshness"/>
<link href="#rfc.section.5" rel="Chapter" title="5 Detailed Technical Description"/>
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Origin and Web Security Issues"/>
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Device Permissions Model"/>
<link href="#rfc.section.5.3" rel="Chapter" title="5.3 Communications Consent"/>
<link href="#rfc.section.5.4" rel="Chapter" title="5.4 IP Location Privacy"/>
<link href="#rfc.section.5.5" rel="Chapter" title="5.5 Communications Security"/>
<link href="#rfc.section.5.6" rel="Chapter" title="5.6 Web-Based Peer Authentication"/>
<link href="#rfc.section.5.6.1" rel="Chapter" title="5.6.1 Trust Relationships: IdPs, APs, and RPs"/>
<link href="#rfc.section.5.6.2" rel="Chapter" title="5.6.2 Overview of Operation"/>
<link href="#rfc.section.5.6.3" rel="Chapter" title="5.6.3 Items for Standardization"/>
<link href="#rfc.section.5.6.4" rel="Chapter" title="5.6.4 Binding Identity Assertions to JSEP Offer/Answer Transactions"/>
<link href="#rfc.section.5.6.4.1" rel="Chapter" title="5.6.4.1 Input to Assertion Generation Process"/>
<link href="#rfc.section.5.6.4.2" rel="Chapter" title="5.6.4.2 Carrying Identity Assertions"/>
<link href="#rfc.section.5.6.4.3" rel="Chapter" title="5.6.4.3 a=identity Attribute"/>
<link href="#rfc.section.5.6.5" rel="Chapter" title="5.6.5 IdP Interaction Details"/>
<link href="#rfc.section.5.6.5.1" rel="Chapter" title="5.6.5.1 General Message Structure"/>
<link href="#rfc.section.5.6.5.2" rel="Chapter" title="5.6.5.2 Errors"/>
<link href="#rfc.section.5.6.5.3" rel="Chapter" title="5.6.5.3 IdP Proxy Setup"/>
<link href="#rfc.section.5.6.5.4" rel="Chapter" title="5.6.5.4 Verifying Assertions"/>
<link href="#rfc.section.6" rel="Chapter" title="6 Security Considerations"/>
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 Communications Security"/>
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 Privacy"/>
<link href="#rfc.section.6.3" rel="Chapter" title="6.3 Denial of Service"/>
<link href="#rfc.section.6.4" rel="Chapter" title="6.4 IdP Authentication Mechanism"/>
<link href="#rfc.section.6.4.1" rel="Chapter" title="6.4.1 PeerConnection Origin Check"/>
<link href="#rfc.section.6.4.2" rel="Chapter" title="6.4.2 IdP Well-known URI"/>
<link href="#rfc.section.6.4.3" rel="Chapter" title="6.4.3 Privacy of IdP-generated identities and the hosting site"/>
<link href="#rfc.section.6.4.4" rel="Chapter" title="6.4.4 Security of Third-Party IdPs"/>
<link href="#rfc.section.6.4.5" rel="Chapter" title="6.4.5 Web Security Feature Interactions"/>
<link href="#rfc.section.6.4.5.1" rel="Chapter" title="6.4.5.1 Popup Blocking"/>
<link href="#rfc.section.6.4.5.2" rel="Chapter" title="6.4.5.2 Third Party Cookies"/>
<link href="#rfc.section.7" rel="Chapter" title="7 IANA Considerations"/>
<link href="#rfc.section.8" rel="Chapter" title="8 Acknowledgements"/>
<link href="#rfc.section.9" rel="Chapter" title="9 Changes"/>
<link href="#rfc.section.9.1" rel="Chapter" title="9.1 Changes since -06"/>
<link href="#rfc.section.9.2" rel="Chapter" title="9.2 Changes since -05"/>
<link href="#rfc.section.9.3" rel="Chapter" title="9.3 Changes since -03"/>
<link href="#rfc.section.9.4" rel="Chapter" title="9.4 Changes since -03"/>
<link href="#rfc.section.9.5" rel="Chapter" title="9.5 Changes since -02"/>
<link href="#rfc.references" rel="Chapter" title="10 References"/>
<link href="#rfc.references.1" rel="Chapter" title="10.1 Normative References"/>
<link href="#rfc.references.2" rel="Chapter" title="10.2 Informative References"/>
<link href="#rfc.appendix.A" rel="Chapter" title="A Example IdP Bindings to Specific Protocols"/>
<link href="#rfc.appendix.A.1" rel="Chapter" title="A.1 BrowserID"/>
<link href="#rfc.appendix.A.2" rel="Chapter" title="A.2 OAuth"/>
<link href="#rfc.authors" rel="Chapter"/>


  <meta name="generator" content="xml2rfc version 2.4.8 - http://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Rescorla, E." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-ietf-rtcweb-security-arch-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2014-7-4" />
  <meta name="dct.abstract" content="The Real-Time Communications on the Web (RTCWEB) working group is tasked with standardizing protocols for enabling real-time communications within user-agents using web technologies (commonly called &quot;WebRTC&quot;). This document defines the security architecture for WebRTC.  " />
  <meta name="description" content="The Real-Time Communications on the Web (RTCWEB) working group is tasked with standardizing protocols for enabling real-time communications within user-agents using web technologies (commonly called &quot;WebRTC&quot;). This document defines the security architecture for WebRTC.  " />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
  <td class="left">RTCWEB</td>
  <td class="right">E. Rescorla</td>
</tr>
<tr>
  <td class="left">Internet-Draft</td>
  <td class="right">RTFM, Inc.</td>
</tr>
<tr>
  <td class="left">Intended status: Standards Track</td>
  <td class="right">July 4, 2014</td>
</tr>
<tr>
  <td class="left">Expires: January 5, 2015</td>
  <td class="right"></td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">WebRTC Security Architecture<br />
  <span class="filename">draft-ietf-rtcweb-security-arch-latest</span></p>
  
  <h1 id="rfc.abstract">
  <a href="#rfc.abstract">Abstract</a>
</h1>
<p>The Real-Time Communications on the Web (RTCWEB) working group is tasked with standardizing protocols for enabling real-time communications within user-agents using web technologies (commonly called "WebRTC"). This document defines the security architecture for WebRTC.  </p>
<h1 id="rfc.status">
  <a href="#rfc.status">Status of This Memo</a>
</h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on January 5, 2015.</p>
<h1 id="rfc.copyrightnotice">
  <a href="#rfc.copyrightnotice">Copyright Notice</a>
</h1>
<p>Copyright (c) 2014 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>
<p>This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008.  The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a></li>
<li>2.   <a href="#rfc.section.2">Terminology</a></li>
<li>3.   <a href="#rfc.section.3">Trust Model</a></li>
<li>3.1.   <a href="#rfc.section.3.1">Authenticated Entities</a></li>
<li>3.2.   <a href="#rfc.section.3.2">Unauthenticated Entities</a></li>
<li>4.   <a href="#rfc.section.4">Overview</a></li>
<li>4.1.   <a href="#rfc.section.4.1">Initial Signaling</a></li>
<li>4.2.   <a href="#rfc.section.4.2">Media Consent Verification</a></li>
<li>4.3.   <a href="#rfc.section.4.3">DTLS Handshake</a></li>
<li>4.4.   <a href="#rfc.section.4.4">Communications and Consent Freshness</a></li>
<li>5.   <a href="#rfc.section.5">Detailed Technical Description</a></li>
<li>5.1.   <a href="#rfc.section.5.1">Origin and Web Security Issues</a></li>
<li>5.2.   <a href="#rfc.section.5.2">Device Permissions Model</a></li>
<li>5.3.   <a href="#rfc.section.5.3">Communications Consent</a></li>
<li>5.4.   <a href="#rfc.section.5.4">IP Location Privacy</a></li>
<li>5.5.   <a href="#rfc.section.5.5">Communications Security</a></li>
<li>5.6.   <a href="#rfc.section.5.6">Web-Based Peer Authentication</a></li>
<li>5.6.1.   <a href="#rfc.section.5.6.1">Trust Relationships: IdPs, APs, and RPs</a></li>
<li>5.6.2.   <a href="#rfc.section.5.6.2">Overview of Operation</a></li>
<li>5.6.3.   <a href="#rfc.section.5.6.3">Items for Standardization</a></li>
<li>5.6.4.   <a href="#rfc.section.5.6.4">Binding Identity Assertions to JSEP Offer/Answer Transactions</a></li>
<li>5.6.4.1.   <a href="#rfc.section.5.6.4.1">Input to Assertion Generation Process</a></li>
<li>5.6.4.2.   <a href="#rfc.section.5.6.4.2">Carrying Identity Assertions</a></li>
<li>5.6.4.3.   <a href="#rfc.section.5.6.4.3">a=identity Attribute</a></li>
<li>5.6.5.   <a href="#rfc.section.5.6.5">IdP Interaction Details</a></li>
<li>5.6.5.1.   <a href="#rfc.section.5.6.5.1">General Message Structure</a></li>
<li>5.6.5.2.   <a href="#rfc.section.5.6.5.2">Errors</a></li>
<li>5.6.5.3.   <a href="#rfc.section.5.6.5.3">IdP Proxy Setup</a></li>
<li>5.6.5.4.   <a href="#rfc.section.5.6.5.4">Verifying Assertions</a></li>
<li>6.   <a href="#rfc.section.6">Security Considerations</a></li>
<li>6.1.   <a href="#rfc.section.6.1">Communications Security</a></li>
<li>6.2.   <a href="#rfc.section.6.2">Privacy</a></li>
<li>6.3.   <a href="#rfc.section.6.3">Denial of Service</a></li>
<li>6.4.   <a href="#rfc.section.6.4">IdP Authentication Mechanism</a></li>
<li>6.4.1.   <a href="#rfc.section.6.4.1">PeerConnection Origin Check</a></li>
<li>6.4.2.   <a href="#rfc.section.6.4.2">IdP Well-known URI</a></li>
<li>6.4.3.   <a href="#rfc.section.6.4.3">Privacy of IdP-generated identities and the hosting site</a></li>
<li>6.4.4.   <a href="#rfc.section.6.4.4">Security of Third-Party IdPs</a></li>
<li>6.4.5.   <a href="#rfc.section.6.4.5">Web Security Feature Interactions</a></li>
<li>6.4.5.1.   <a href="#rfc.section.6.4.5.1">Popup Blocking</a></li>
<li>6.4.5.2.   <a href="#rfc.section.6.4.5.2">Third Party Cookies</a></li>
<li>7.   <a href="#rfc.section.7">IANA Considerations</a></li>
<li>8.   <a href="#rfc.section.8">Acknowledgements</a></li>
<li>9.   <a href="#rfc.section.9">Changes</a></li>
<li>9.1.   <a href="#rfc.section.9.1">Changes since -06</a></li>
<li>9.2.   <a href="#rfc.section.9.2">Changes since -05</a></li>
<li>9.3.   <a href="#rfc.section.9.3">Changes since -03</a></li>
<li>9.4.   <a href="#rfc.section.9.4">Changes since -03</a></li>
<li>9.5.   <a href="#rfc.section.9.5">Changes since -02</a></li>
<li>10.   <a href="#rfc.references">References</a></li>
<li>10.1.   <a href="#rfc.references.1">Normative References</a></li>
<li>10.2.   <a href="#rfc.references.2">Informative References</a></li>
<li>Appendix A.   <a href="#rfc.appendix.A">Example IdP Bindings to Specific Protocols</a></li>
<li>A.1.   <a href="#rfc.appendix.A.1">BrowserID</a></li>
<li>A.2.   <a href="#rfc.appendix.A.2">OAuth</a></li>
<li><a href="#rfc.authors">Author's Address</a></li>


  </ul>

  <h1 id="rfc.section.1"><a href="#rfc.section.1">1.</a> <a href="#sec.introduction" id="sec.introduction">Introduction</a></h1>
<p id="rfc.section.1.p.1">The Real-Time Communications on the Web (WebRTC) working group is tasked with standardizing protocols for real-time communications between Web browsers. The major use cases for WebRTC technology are real-time audio and/or video calls, Web conferencing, and direct data transfer. Unlike most conventional real-time systems, (e.g., SIP-based<a href="#RFC3261">[RFC3261]</a> soft phones) WebRTC communications are directly controlled by some Web server, via a JavaScript (JS) API as shown in <a href="#fig.simple">Figure 1</a>.  </p>
<div id="rfc.figure.1"/>
<div id="fig.simple"/>
<pre>
                            +----------------+
                            |                |
                            |   Web Server   |
                            |                |
                            +----------------+
                                ^        ^
                               /          \
                       HTTP   /            \   HTTP
                             /              \
                            /                \
                           v                  v
                        JS API              JS API
                  +-----------+            +-----------+
                  |           |    Media   |           |
                  |  Browser  |&lt;----------&gt;|  Browser  |
                  |           |            |           |
                  +-----------+            +-----------+
</pre>
<p class="figure">Figure 1: A simple WebRTC system</p>
<p id="rfc.section.1.p.2">A more complicated system might allow for interdomain calling, as shown in <a href="#fig.multidomain">Figure 2</a>.  The protocol to be used between the domains is not standardized by WebRTC, but given the installed base and the form of the WebRTC API is likely to be something SDP-based like SIP.  </p>
<div id="rfc.figure.2"/>
<div id="fig.multidomain"/>
<pre>
                 +--------------+             +--------------+
                 |              | SIP,XMPP,...|              |
                 |  Web Server  |&lt;-----------&gt;|  Web Server  |
                 |              |             |              |
                 +--------------+             +--------------+
                        ^                             ^
                        |                             |
                  HTTP  |                             |  HTTP
                        |                             |
                        v                             v
                        JS API                    JS API
                  +-----------+                  +-----------+
                  |           |        Media     |           |
                  |  Browser  |&lt;----------------&gt;|  Browser  |
                  |           |                  |           |
                  +-----------+                  +-----------+
</pre>
<p class="figure">Figure 2: A multidomain WebRTC system</p>
<p id="rfc.section.1.p.3">This system presents a number of new security challenges, which are analyzed in <a href="#I-D.ietf-rtcweb-security">[I-D.ietf-rtcweb-security]</a>.  This document describes a security architecture for WebRTC which addresses the threats and requirements described in that document.  </p>
<h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a> <a href="#sec-term" id="sec-term">Terminology</a></h1>
<p id="rfc.section.2.p.1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a href="#RFC2119">RFC 2119</a> <cite title="NONE">[RFC2119]</cite>.  </p>
<h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a> <a href="#sec.proposal.trusthierarchy" id="sec.proposal.trusthierarchy">Trust Model</a></h1>
<p id="rfc.section.3.p.1">The basic assumption of this architecture is that network resources exist in a hierarchy of trust, rooted in the browser, which serves as the user's TRUSTED COMPUTING BASE (TCB). Any security property which the user wishes to have enforced must be ultimately guaranteed by the browser (or transitively by some property the browser verifies). Conversely, if the browser is compromised, then no security guarantees are possible.  Note that there are cases (e.g., Internet kiosks) where the user can't really trust the browser that much. In these cases, the level of security provided is limited by how much they trust the browser.  </p>
<p id="rfc.section.3.p.2">Optimally, we would not rely on trust in any entities other than the browser. However, this is unfortunately not possible if we wish to have a functional system.  Other network elements fall into two categories: those which can be authenticated by the browser and thus are partly trusted--though to the minimum extent necessary--and those which cannot be authenticated and thus are untrusted.  </p>
<h1 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1.</a> <a href="#sec.proposal.authenticated" id="sec.proposal.authenticated">Authenticated Entities</a></h1>
<p id="rfc.section.3.1.p.1">There are two major classes of authenticated entities in the system: </p>
<p/>

<ul>
  <li>Calling services: Web sites whose origin we can verify (optimally via HTTPS, but in some cases because we are on a topologically restricted network, such as behind a firewall, and can infer authentication from firewall behavior).  </li>
  <li>Other users: WebRTC peers whose origin we can verify cryptographically (optimally via DTLS-SRTP).  </li>
</ul>

<p> </p>
<p id="rfc.section.3.1.p.3">Note that merely being authenticated does not make these entities trusted. For instance, just because we can verify that https://www.evil.org/ is owned by Dr. Evil does not mean that we can trust Dr. Evil to access our camera and microphone. However, it gives the user an opportunity to determine whether he wishes to trust Dr. Evil or not; after all, if he desires to contact Dr. Evil (perhaps to arrange for ransom payment), it's safe to temporarily give him access to the camera and microphone for the purpose of the call, but he doesn't want Dr. Evil to be able to access his camera and microphone other than during the call. The point here is that we must first identify other elements before we can determine whether and how much to trust them. Additionally, sometimes we need to identify the communicating peer before we know what policies to apply.  </p>
<p id="rfc.section.3.1.p.4">It's also worth noting that there are settings where authentication is non-cryptographic, such as other machines behind a firewall. Naturally, the level of trust one can have in identities verified in this way depends on how strong the topology enforcement is.  </p>
<h1 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2.</a> <a href="#sec.proposal.unauthenticated" id="sec.proposal.unauthenticated">Unauthenticated Entities</a></h1>
<p id="rfc.section.3.2.p.1">Other than the above entities, we are not generally able to identify other network elements, thus we cannot trust them.  This does not mean that it is not possible to have any interaction with them, but it means that we must assume that they will behave maliciously and design a system which is secure even if they do so.  </p>
<h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a> <a href="#sec.proposal.overview" id="sec.proposal.overview">Overview</a></h1>
<p id="rfc.section.4.p.1">This section describes a typical RTCWeb session and shows how the various security elements interact and what guarantees are provided to the user. The example in this section is a "best case" scenario in which we provide the maximal amount of user authentication and media privacy with the minimal level of trust in the calling service. Simpler versions with lower levels of security are also possible and are noted in the text where applicable. It's also important to recognize the tension between security (or performance) and privacy. The example shown here is aimed towards settings where we are more concerned about secure calling than about privacy, but as we shall see, there are settings where one might wish to make different tradeoffs--this architecture is still compatible with those settings.  </p>
<p id="rfc.section.4.p.2">For the purposes of this example, we assume the topology shown in the figures below. This topology is derived from the topology shown in <a href="#fig.simple">Figure 1</a>, but separates Alice and Bob's identities from the process of signaling.  Specifically, Alice and Bob have relationships with some Identity Provider (IdP) that supports a protocol such as OpenID or BrowserID) that can be used to demonstrate their identity to other parties. For instance, Alice might have an account with a social network which she can then use to authenticate to other web sites without explicitly having an account with those sites; this is a fairly conventional pattern on the Web. <a href="#sec.trust-relationships">Section 5.6.1</a> provides an overview of Identity Providers and the relevant terminology.  Alice and Bob might have relationships with different IdPs as well.  </p>
<p id="rfc.section.4.p.3">This separation of identity provision and signaling isn't particularly important in "closed world" cases where Alice and Bob are users on the same social network and have identities based on that domain (<a href="#fig.proposal.idp">Figure 3</a>) However, there are important settings where that is not the case, such as federation (calls from one domain to another; <a href="#fig.proposal-federated.idp">Figure 4</a>) and calling on untrusted sites, such as where two users who have a relationship via a given social network want to call each other on another, untrusted, site, such as a poker site.  </p>
<p id="rfc.section.4.p.4">Note that the servers themselves are also authenticated by an external identity service, the SSL/TLS certificate infrastructure (not shown).  As is conventional in the Web, all identities are ultimately rooted in that system. For instance, when an IdP makes an identity assertion, the Relying Party consuming that assertion is able to verify because it is able to connect to the IdP via HTTPS.  </p>
<div id="rfc.figure.3"/>
<div id="fig.proposal.idp"/>
<pre>
                            +----------------+
                            |                |
                            |     Signaling  |
                            |     Server     |
                            |                |
                            +----------------+
                                ^        ^
                               /          \
                       HTTPS  /            \   HTTPS
                             /              \
                            /                \
                           v                  v
                        JS API              JS API
                  +-----------+            +-----------+
                  |           |    Media   |           |
            Alice |  Browser  |&lt;----------&gt;|  Browser  | Bob
                  |           | (DTLS+SRTP)|           |
                  +-----------+            +-----------+
                        ^      ^--+     +--^     ^
                        |         |     |        |
                        v         |     |        v
                  +-----------+   |     |  +-----------+
                  |           |&lt;--------+  |           |
                  |   IdP1    |   |        |    IdP2   |
                  |           |   +-------&gt;|           |
                  +-----------+            +-----------+
</pre>
<p class="figure">Figure 3: A call with IdP-based identity</p>
<p><a href="#fig.proposal-federated.idp">Figure 4</a> shows essentially the same calling scenario but with a call between two separate domains (i.e., a federated case), as in <a href="#fig.multidomain">Figure 2</a>. As mentioned above, the domains communicate by some unspecified protocol and providing separate signaling and identity allows for calls to be authenticated regardless of the details of the inter-domain protocol.  </p>
<div id="rfc.figure.4"/>
<div id="fig.proposal-federated.idp"/>
<pre>
        +----------------+    Unspecified    +----------------+
        |                |      protocol     |                |
        |    Signaling   |&lt;-----------------&gt;|    Signaling   |
        |    Server      |  (SIP, XMPP, ...) |    Server      |
        |                |                   |                |
        +----------------+                   +----------------+
                 ^                                   ^
                 |                                   |
           HTTPS |                                   | HTTPS
                 |                                   |
                 |                                   |
                 v                                   v
              JS API                               JS API
        +-----------+                             +-----------+
        |           |             Media           |           |
  Alice |  Browser  |&lt;---------------------------&gt;|  Browser  | Bob
        |           |           DTLS+SRTP         |           |
        +-----------+                             +-----------+
              ^      ^--+                      +--^     ^
              |         |                      |        |
              v         |                      |        v
        +-----------+   |                      |  +-----------+
        |           |&lt;-------------------------+  |           |
        |   IdP1    |   |                         |    IdP2   |
        |           |   +------------------------&gt;|           |
        +-----------+                             +-----------+
</pre>
<p class="figure">Figure 4: A federated call with IdP-based identity</p>
<h1 id="rfc.section.4.1"><a href="#rfc.section.4.1">4.1.</a> Initial Signaling</h1>
<p id="rfc.section.4.1.p.1">For simplicity, assume the topology in <a href="#fig.proposal.idp">Figure 3</a>.  Alice and Bob are both users of a common calling service; they both have approved the calling service to make calls (we defer the discussion of device access permissions till later).  They are both connected to the calling service via HTTPS and so know the origin with some level of confidence. They also have accounts with some identity provider.  This sort of identity service is becoming increasingly common in the Web environment in technologies such (BrowserID, Federated Google Login, Facebook Connect, OAuth, OpenID, WebFinger), and is often provided as a side effect service of a user's ordinary accounts with some service. In this example, we show Alice and Bob using a separate identity service, though the identity service may be the same entity as the calling service or there may be no identity service at all.  </p>
<p id="rfc.section.4.1.p.2">Alice is logged onto the calling service and decides to call Bob.  She can see from the calling service that he is online and the calling service presents a JS UI in the form of a button next to Bob's name which says "Call". Alice clicks the button, which initiates a JS callback that instantiates a PeerConnection object. This does not require a security check: JS from any origin is allowed to get this far.  </p>
<p id="rfc.section.4.1.p.3">Once the PeerConnection is created, the calling service JS needs to set up some media. Because this is an audio/video call, it creates a MediaStream with two MediaStreamTracks, one connected to an audio input and one connected to a video input. At this point the first security check is required: untrusted origins are not allowed to access the camera and microphone, so the browser prompts Alice for permission.  </p>
<p id="rfc.section.4.1.p.4">In the current W3C API, once some streams have been added, Alice's browser + JS generates a signaling message <a href="#I-D.ietf-rtcweb-jsep">[I-D.ietf-rtcweb-jsep]</a> containing: </p>
<p/>

<ul>
  <li>Media channel information </li>
  <li>Interactive Connectivity Establishment (ICE) <a href="#RFC5245">[RFC5245]</a> candidates </li>
  <li>A fingerprint attribute binding the communication to a key pair <a href="#RFC5763">[RFC5763]</a>. Note that this key may simply be ephemerally generated for this call or specific to this domain, and Alice may have a large number of such keys.  </li>
</ul>

<p> </p>
<p id="rfc.section.4.1.p.6">Prior to sending out the signaling message, the PeerConnection code contacts the identity service and obtains an assertion binding Alice's identity to her fingerprint. The exact details depend on the identity service (though as discussed in <a href="#sec.generic.idp">Section 5.6</a> PeerConnection can be agnostic to them), but for now it's easiest to think of as a BrowserID assertion.  The assertion may bind other information to the identity besides the fingerprint, but at minimum it needs to bind the fingerprint.  </p>
<p id="rfc.section.4.1.p.7">This message is sent to the signaling server, e.g., by XMLHttpRequest <a href="#XmlHttpRequest">[XmlHttpRequest]</a> or by WebSockets <a href="#RFC6455">[RFC6455]</a>.  preferably over TLS <a href="#RFC5246">[RFC5246]</a>.  The signaling server processes the message from Alice's browser, determines that this is a call to Bob and sends a signaling message to Bob's browser (again, the format is currently undefined).  The JS on Bob's browser processes it, and alerts Bob to the incoming call and to Alice's identity. In this case, Alice has provided an identity assertion and so Bob's browser contacts Alice's identity provider (again, this is done in a generic way so the browser has no specific knowledge of the IdP) to verify the assertion. This allows the browser to display a trusted element in the browser chrome indicating that a call is coming in from Alice. If Alice is in Bob's address book, then this interface might also include her real name, a picture, etc.  The calling site will also provide some user interface element (e.g., a button) to allow Bob to answer the call, though this is most likely not part of the trusted UI.  </p>
<p id="rfc.section.4.1.p.8">If Bob agrees a PeerConnection is instantiated with the message from Alice's side.  Then, a similar process occurs as on Alice's browser: Bob's browser prompts him for device permission, the media streams are created, and a return signaling message containing media information, ICE candidates, and a fingerprint is sent back to Alice via the signaling service.  If Bob has a relationship with an IdP, the message will also come with an identity assertion.  </p>
<p id="rfc.section.4.1.p.9">At this point, Alice and Bob each know that the other party wants to have a secure call with them. Based purely on the interface provided by the signaling server, they know that the signaling server claims that the call is from Alice to Bob. This level of security is provided merely by having the fingerprint in the message and having that message received securely from the signaling server.  Because the far end sent an identity assertion along with their message, they know that this is verifiable from the IdP as well. Note that if the call is federated, as shown in <a href="#fig.proposal-federated.idp">Figure 4</a> then Alice is able to verify Bob's identity in a way that is not mediated by either her signaling server or Bob's. Rather, she verifies it directly with Bob's IdP.  </p>
<p id="rfc.section.4.1.p.10">Of course, the call works perfectly well if either Alice or Bob doesn't have a relationship with an IdP; they just get a lower level of assurance. I.e., they simply have whatever information their calling site claims about the caller/calllee's identity.  Moreover, Alice might wish to make an anonymous call through an anonymous calling site, in which case she would of course just not provide any identity assertion and the calling site would mask her identity from Bob.  </p>
<h1 id="rfc.section.4.2"><a href="#rfc.section.4.2">4.2.</a> Media Consent Verification</h1>
<p id="rfc.section.4.2.p.1">As described in (<a href="#I-D.ietf-rtcweb-security">[I-D.ietf-rtcweb-security]</a>; Section 4.2) media consent verification is provided via ICE.  Thus, Alice and Bob perform ICE checks with each other.  At the completion of these checks, they are ready to send non-ICE data.  </p>
<p id="rfc.section.4.2.p.2">At this point, Alice knows that (a) Bob (assuming he is verified via his IdP) or someone else who the signaling service is claiming is Bob is willing to exchange traffic with her and (b) that either Bob is at the IP address which she has verified via ICE or there is an attacker who is on-path to that IP address detouring the traffic. Note that it is not possible for an attacker who is on-path between Alice and Bob but not attached to the signaling service to spoof these checks because they do not have the ICE credentials. Bob has the same security guarantees with respect to Alice.  </p>
<h1 id="rfc.section.4.3"><a href="#rfc.section.4.3">4.3.</a> DTLS Handshake</h1>
<p id="rfc.section.4.3.p.1">Once the ICE checks have completed [more specifically, once some ICE checks have completed], Alice and Bob can set up a secure channel or channels. This is performed via DTLS <a href="#RFC4347">[RFC4347]</a> (for the data channel) and DTLS-SRTP <a href="#RFC5763">[RFC5763]</a> keying for SRTP <a href="#RFC3711">[RFC3711]</a> for the media channel and SCTP over DTLS <a href="#I-D.ietf-tsvwg-sctp-dtls-encaps">[I-D.ietf-tsvwg-sctp-dtls-encaps]</a> for data channels. Specifically, Alice and Bob perform a DTLS handshake on every channel which has been established by ICE. The total number of channels depends on the amount of muxing; in the most likely case we are using both RTP/RTCP mux and muxing multiple media streams on the same channel, in which case there is only one DTLS handshake. Once the DTLS handshake has completed, the keys are exported <a href="#RFC5705">[RFC5705]</a> and used to key SRTP for the media channels.  </p>
<p id="rfc.section.4.3.p.2">At this point, Alice and Bob know that they share a set of secure data and/or media channels with keys which are not known to any third-party attacker. If Alice and Bob authenticated via their IdPs, then they also know that the signaling service is not mounting a man-in-the-middle attack on their traffic. Even if they do not use an IdP, as long as they have minimal trust in the signaling service not to perform a man-in-the-middle attack, they know that their communications are secure against the signaling service as well (i.e., that the signaling service cannot mount a passive attack on the communications).  </p>
<h1 id="rfc.section.4.4"><a href="#rfc.section.4.4">4.4.</a> Communications and Consent Freshness</h1>
<p id="rfc.section.4.4.p.1">From a security perspective, everything from here on in is a little anticlimactic: Alice and Bob exchange data protected by the keys negotiated by DTLS. Because of the security guarantees discussed in the previous sections, they know that the communications are encrypted and authenticated.  </p>
<p id="rfc.section.4.4.p.2">The one remaining security property we need to establish is "consent freshness", i.e., allowing Alice to verify that Bob is still prepared to receive her communications so that Alice does not continue to send large traffic volumes to entities which went abruptly offline. ICE specifies periodic STUN keepalizes but only if media is not flowing.  Because the consent issue is more difficult here, we require RTCWeb implementations to periodically send keepalives.  As described in Section 5.3, these keepalives MUST be based on the consent freshness mechanism specified in <a href="#I-D.muthu-behave-consent-freshness">[I-D.muthu-behave-consent-freshness]</a>.  If a keepalive fails and no new ICE channels can be established, then the session is terminated.  </p>
<h1 id="rfc.section.5"><a href="#rfc.section.5">5.</a> <a href="#sec.proposal.detailed" id="sec.proposal.detailed">Detailed Technical Description</a></h1>
<h1 id="rfc.section.5.1"><a href="#rfc.section.5.1">5.1.</a> <a href="#sec.proposal.origin" id="sec.proposal.origin">Origin and Web Security Issues</a></h1>
<p id="rfc.section.5.1.p.1">The basic unit of permissions for WebRTC is the origin <a href="#RFC6454">[RFC6454]</a>. Because the security of the origin depends on being able to authenticate content from that origin, the origin can only be securely established if data is transferred over HTTPS <a href="#RFC2818">[RFC2818]</a>. Thus, clients MUST treat HTTP and HTTPS origins as different permissions domains. [Note: this follows directly from the origin security model and is stated here merely for clarity.] </p>
<p id="rfc.section.5.1.p.2">Many web browsers currently forbid by default any active mixed content on HTTPS pages. That is, when JavaScript is loaded from an HTTP origin onto an HTTPS page, an error is displayed and the HTTP content is not executed unless the user overrides the error. Any browser which enforces such a policy will also not permit access to WebRTC functionality from mixed content pages (because they never display mixed content).  Browsers which allow active mixed content MUST nevertheless disable WebRTC functionality in mixed content settings.  </p>
<p id="rfc.section.5.1.p.3">Note that it is possible for a page which was not mixed content to become mixed content during the duration of the call.  The major risk here is that the newly arrived insecure JS might redirect media to a location controlled by the attacker.  Implementations MUST either choose to terminate the call or display a warning at that point.  </p>
<h1 id="rfc.section.5.2"><a href="#rfc.section.5.2">5.2.</a> <a href="#sec.proposal.device.permissions" id="sec.proposal.device.permissions">Device Permissions Model</a></h1>
<p id="rfc.section.5.2.p.1">Implementations MUST obtain explicit user consent prior to providing access to the camera and/or microphone. Implementations MUST at minimum support the following two permissions models for HTTPS origins.  </p>
<p/>

<ul>
  <li>Requests for one-time camera/microphone access.  </li>
  <li>Requests for permanent access.  </li>
</ul>

<p> </p>
<p id="rfc.section.5.2.p.3">Because HTTP origins cannot be securely established against network attackers, implementations MUST NOT allow the setting of permanent access permissions for HTTP origins. Implementations MAY also opt to refuse all permissions grants for HTTP origins, but it is RECOMMENDED that currently they support one-time camera/microphone access.  </p>
<p id="rfc.section.5.2.p.4">In addition, they SHOULD support requests for access that promise that media from this grant will be sent to a single communicating peer (obviously there could be other requests for other peers).  E.g., "Call customerservice@ford.com".  The semantics of this request are that the media stream from the camera and microphone will only be routed through a connection which has been cryptographically verified (through the IdP mechanism or an X.509 certificate in the DTLS-SRTP handshake) as being associated with the stated identity. Note that it is unlikely that browsers would have an X.509 certificate, but servers might.  Browsers servicing such requests SHOULD clearly indicate that identity to the user when asking for permission.  The idea behind this type of permissions is that a user might have a fairly narrow list of peers he is willing to communicate with, e.g., "my mother" rather than "anyone on Facebook". Narrow permissions grants allow the browser to do that enforcement.  </p>
<p/>

<dl>
  <dt>API Requirement:</dt>
  <dd style="margin-left: 8">The API MUST provide a mechanism for the requesting JS to indicate which of these forms of permissions it is requesting. This allows the browser client to know what sort of user interface experience to provide to the user, including what permissions to request from the user and hence what to enforce later.  For instance, browsers might display a non-invasive door hanger ("some features of this site may not work..." when asking for long-term permissions) but a more invasive UI ("here is your own video") for single-call permissions. The API MAY grant weaker permissions than the JS asked for if the user chooses to authorize only those permissions, but if it intends to grant stronger ones it SHOULD display the appropriate UI for those permissions and MUST clearly indicate what permissions are being requested.  </dd>
</dl>

<p> </p>
<p/>

<dl>
  <dt>API Requirement:</dt>
  <dd style="margin-left: 8">The API MUST provide a mechanism for the requesting JS to relinquish the ability to see or modify the media (e.g., via MediaStream.record()).  Combined with secure authentication of the communicating peer, this allows a user to be sure that the calling site is not accessing or modifying their conversion.  </dd>
</dl>

<p> </p>
<p/>

<dl>
  <dt>UI Requirement:</dt>
  <dd style="margin-left: 8">The UI MUST clearly indicate when the user's camera and microphone are in use.  This indication MUST NOT be suppressable by the JS and MUST clearly indicate how to terminate device access, and provide a UI means to immediately stop camera/microphone input without the JS being able to prevent it.  </dd>
</dl>

<p> </p>
<p/>

<dl>
  <dt>UI Requirement:</dt>
  <dd style="margin-left: 8">If the UI indication of camera/microphone use are displayed in the browser such that minimizing the browser window would hide the indication, or the JS creating an overlapping window would hide the indication, then the browser SHOULD stop camera and microphone input when the indication is hidden.  [Note: this may not be necessary in systems that are non-windows-based but that have good notifications support, such as phones.] </dd>
</dl>

<p> </p>
<p id="rfc.section.5.2.p.9">[[OPEN ISSUE: This section does not have WG consensus.  Because screen/application sharing presents a more significant risk than camera and microphone access (see the discussion in <a href="#I-D.ietf-rtcweb-security">[I-D.ietf-rtcweb-security]</a> S 4.1.1), we require a higher level of user consent.  </p>
<p/>

<ul>
  <li>Browsers MUST not permit permanent screen or application sharing permissions to be installed as a response to a JS request for permissions. Instead, they must require some other user action such as a permissions setting or an application install experience to grant permission to a site.  </li>
  <li>Browsers MUST provide a separate dialog request for screen/application sharing permissions even if the media request is made at the same time as camera and microphone.  </li>
  <li>The browser MUST indicate any windows which are currently being shared in some unambiguous way. Windows which are not visible MUST not be shared even if the application is being shared.  If the screen is being shared, then that MUST be indicated.  </li>
</ul>

<p> </p>
<p id="rfc.section.5.2.p.11">-- END OF OPEN ISSUE]] </p>
<p id="rfc.section.5.2.p.12">Clients MAY permit the formation of data channels without any direct user approval. Because sites can always tunnel data through the server, further restrictions on the data channel do not provide any additional security.  (though see <a href="#sec.proposal.communications.consent">Section 5.3</a> for a related issue).  </p>
<p id="rfc.section.5.2.p.13">Implementations which support some form of direct user authentication SHOULD also provide a policy by which a user can authorize calls only to specific communicating peers. Specifically, the implementation SHOULD provide the following interfaces/controls: </p>
<p/>

<ul>
  <li>Allow future calls to this verified user.  </li>
  <li>Allow future calls to any verified user who is in my system address book (this only works with address book integration, of course).  </li>
</ul>

<p> </p>
<p id="rfc.section.5.2.p.15">Implementations SHOULD also provide a different user interface indication when calls are in progress to users whose identities are directly verifiable.  <a href="#sec.proposal.comsec">Section 5.5</a> provides more on this.  </p>
<h1 id="rfc.section.5.3"><a href="#rfc.section.5.3">5.3.</a> <a href="#sec.proposal.communications.consent" id="sec.proposal.communications.consent">Communications Consent</a></h1>
<p id="rfc.section.5.3.p.1">Browser client implementations of WebRTC MUST implement ICE.  Server gateway implementations which operate only at public IP addresses MUST implement either full ICE or ICE-Lite <a href="#RFC5245">[RFC5245]</a>.  </p>
<p id="rfc.section.5.3.p.2">Browser implementations MUST verify reachability via ICE prior to sending any non-ICE packets to a given destination.  Implementations MUST NOT provide the ICE transaction ID to JavaScript during the lifetime of the transaction (i.e., during the period when the ICE stack would accept a new response for that transaction).  The JS MUST NOT be permitted to control the local ufrag and password, though it of course knows it.  </p>
<p id="rfc.section.5.3.p.3">While continuing consent is required, that ICE <a href="#RFC5245">[RFC5245]</a>; Section 10 keepalives STUN Binding Indications are one-way and therefore not sufficient.  The current WG consensus is to use ICE Binding Requests for continuing consent freshness. ICE already requires that implementations respond to such requests, so this approach is maximally compatible. A separate document will profile the ICE timers to be used; see <a href="#I-D.muthu-behave-consent-freshness">[I-D.muthu-behave-consent-freshness]</a>.  </p>
<h1 id="rfc.section.5.4"><a href="#rfc.section.5.4">5.4.</a> <a href="#sec.proposal.ip.location.privacy" id="sec.proposal.ip.location.privacy">IP Location Privacy</a></h1>
<p id="rfc.section.5.4.p.1">A side effect of the default ICE behavior is that the peer learns one's IP address, which leaks large amounts of location information. This has negative privacy consequences in some circumstances. The API requirements in this section are intended to mitigate this issue. Note that these requirements are NOT intended to protect the user's IP address from a malicious site. In general, the site will learn at least a user's server reflexive address from any HTTP transaction.  Rather, these requirements are intended to allow a site to cooperate with the user to hide the user's IP address from the other side of the call. Hiding the user's IP address from the server requires some sort of explicit privacy preserving mechanism on the client (e.g., Torbutton [https://www.torproject.org/torbutton/]) and is out of scope for this specification.  </p>
<p/>

<dl>
  <dt>API Requirement:</dt>
  <dd style="margin-left: 8">The API MUST provide a mechanism to allow the JS to suppress ICE negotiation (though perhaps to allow candidate gathering) until the user has decided to answer the call [note: determining when the call has been answered is a question for the JS.]  This enables a user to prevent a peer from learning their IP address if they elect not to answer a call and also from learning whether the user is online.  </dd>
</dl>

<p> </p>
<p/>

<dl>
  <dt>API Requirement:</dt>
  <dd style="margin-left: 8">The API MUST provide a mechanism for the calling application JS to indicate that only TURN candidates are to be used. This prevents the peer from learning one's IP address at all.  This mechanism MUST also permit suppression of the related address field, since that leaks local addresses.  </dd>
</dl>

<p> </p>
<p/>

<dl>
  <dt>API Requirement:</dt>
  <dd style="margin-left: 8">The API MUST provide a mechanism for the calling application to reconfigure an existing call to add non-TURN candidates.  Taken together, this and the previous requirement allow ICE negotiation to start immediately on incoming call notification, thus reducing post-dial delay, but also to avoid disclosing the user's IP address until they have decided to answer. They also allow users to completely hide their IP address for the duration of the call. Finally, they allow a mechanism for the user to optimize performance by reconfiguring to allow non-turn candidates during an active call if the user decides they no longer need to hide their IP address </dd>
</dl>

<p> </p>
<p id="rfc.section.5.4.p.5">Note that some enterprises may operate proxies and/or NATs designed to hide internal IP addresses from the outside world. WebRTC provides no explicit mechanism to allow this function. Either such enterprises need to proxy the HTTP/HTTPS and modify the SDP and/or the JS, or there needs to be browser support to set the "TURN-only" policy regardless of the site's preferences.  </p>
<h1 id="rfc.section.5.5"><a href="#rfc.section.5.5">5.5.</a> <a href="#sec.proposal.comsec" id="sec.proposal.comsec">Communications Security</a></h1>
<p id="rfc.section.5.5.p.1">Implementations MUST implement SRTP <a href="#RFC3711">[RFC3711]</a>.  Implementations MUST implement DTLS <a href="#RFC4347">[RFC4347]</a> and DTLS-SRTP <a href="#RFC5763">[RFC5763]</a><a href="#RFC5764">[RFC5764]</a> for SRTP keying. Implementations MUST implement <a href="#I-D.ietf-tsvwg-sctp-dtls-encaps">[I-D.ietf-tsvwg-sctp-dtls-encaps]</a>.  </p>
<p id="rfc.section.5.5.p.2">All media channels MUST be secured via SRTP.  Media traffic MUST NOT be sent over plain (unencrypted) RTP; that is, implementations MUST NOT negotiate cipher suites with NULL encryption modes.  DTLS-SRTP MUST be offered for every media channel.  WebRTC implementations MUST NOT offer SDES or select it if offered.  </p>
<p id="rfc.section.5.5.p.3">All data channels MUST be secured via DTLS.  </p>
<p id="rfc.section.5.5.p.4">All implementations MUST implement both DTLS 1.2 and DTLS 1.0, with the cipher suites TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 and TLS_DHE_RSA_WITH_AES_128_CBC_SHA and the DTLS-SRTP protection profile SRTP_AES128_CM_HMAC_SHA1_80. Implementations SHOULD favor cipher suites which support PFS over non-PFS cipher suites and GCM over CBC cipher suites.  [[OPEN ISSUE: Should we require ECDHE? Waiting for TLS WG Consensus.]] </p>
<p/>

<dl>
  <dt>API Requirement:</dt>
  <dd style="margin-left: 8">The API MUST provide a mechanism to indicate that a fresh DTLS key pair is to be generated for a specific call.  This is intended to allow for unlinkability. Note that there are also settings where it is attractive to use the same keying material repeatedly, especially those with key continuity-based authentication.  Unless the user specifically configures an external key pair, different key pairs MUST be used for each origin. (This avoids creating a super-cookie.) </dd>
</dl>

<p> </p>
<p/>

<dl>
  <dt>API Requirement:</dt>
  <dd style="margin-left: 8">When DTLS-SRTP is used, the API MUST NOT permit the JS to obtain the negotiated keying material. This requirement preserves the end-to-end security of the media.  </dd>
</dl>

<p> </p>
<p/>

<dl>
  <dt>UI Requirements: </dt>
  <dd style="margin-left: 8">A user-oriented client MUST provide an "inspector" interface which allows the user to determine the security characteristics of the media.  </dd>
  <dt></dt>
  <dd style="margin-left: 8">The following properties SHOULD be displayed "up-front" in the browser chrome, i.e., without requiring the user to ask for them: </dd>
  <dt></dt>
  <dd style="margin-left: 8">
    <ul>
      <li>A client MUST provide a user interface through which a user may determine the security characteristics for currently-displayed audio and video stream(s) </li>
      <li>A client MUST provide a user interface through which a user may determine the security characteristics for transmissions of their microphone audio and camera video.  </li>
      <li>The "security characteristics" MUST include an indication as to whether the cryptographic keys were delivered out-of-band (from a server) or were generated as a result of a pairwise negotiation.  </li>
      <li>If the far endpoint was directly verified, either via a third-party verifiable X.509 certificate or via a Web IdP mechanism (see <a href="#sec.generic.idp">Section 5.6</a>) the "security characteristics" MUST include the verified information.  X.509 identities and Web IdP identities have similar semantics and should be displayed in a similar way.  </li>
    </ul>
    <p> </p>
  </dd>
  <dt></dt>
  <dd style="margin-left: 8"/>
  <dt></dt>
  <dd style="margin-left: 8">The following properties are more likely to require some "drill-down" from the user: </dd>
  <dt></dt>
  <dd style="margin-left: 8">
    <ul>
      <li>The "security characteristics" MUST indicate the cryptographic algorithms in use (For example: "AES-CBC" or "Null Cipher".) However, if Null ciphers are used, that MUST be presented to the user at the top-level UI.  </li>
      <li>The "security characteristics" MUST indicate whether PFS is provided.  </li>
      <li>The "security characteristics" MUST include some mechanism to allow an out-of-band verification of the peer, such as a certificate fingerprint or an SAS.  </li>
    </ul>
    <p> </p>
  </dd>
</dl>

<p> </p>
<h1 id="rfc.section.5.6"><a href="#rfc.section.5.6">5.6.</a> <a href="#sec.generic.idp" id="sec.generic.idp">Web-Based Peer Authentication</a></h1>
<p id="rfc.section.5.6.p.1">In a number of cases, it is desirable for the endpoint (i.e., the browser) to be able to directly identity the endpoint on the other side without trusting only the signaling service to which they are connected. For instance, users may be making a call via a federated system where they wish to get direct authentication of the other side. Alternately, they may be making a call on a site which they minimally trust (such as a poker site) but to someone who has an identity on a site they do trust (such as a social network.) </p>
<p id="rfc.section.5.6.p.2">Recently, a number of Web-based identity technologies (OAuth, BrowserID, Facebook Connect), etc. have been developed. While the details vary, what these technologies share is that they have a Web-based (i.e., HTTP/HTTPS) identity provider which attests to your identity. For instance, if I have an account at example.org, I could use the example.org identity provider to prove to others that I was alice@example.org.  The development of these technologies allows us to separate calling from identity provision: I could call you on Poker Galaxy but identify myself as alice@example.org.  </p>
<p id="rfc.section.5.6.p.3">Whatever the underlying technology, the general principle is that the party which is being authenticated is NOT the signaling site but rather the user (and their browser). Similarly, the relying party is the browser and not the signaling site.  Thus, the browser MUST securely generate the input to the IdP assertion process and MUST securely display the results of the verification process to the user in a way which cannot be imitated by the calling site.  </p>
<p id="rfc.section.5.6.p.4">The mechanisms defined in this document do not require the browser to implement any particular identity protocol or to support any particular IdP. Instead, this document provides a generic interface which any IdP can implement. Thus, new IdPs and protocols can be introduced without change to either the browser or the calling service. This avoids the need to make a commitment to any particular identity protocol, although browsers may opt to directly implement some identity protocols in order to provide superior performance or UI properties.  </p>
<h1 id="rfc.section.5.6.1"><a href="#rfc.section.5.6.1">5.6.1.</a> <a href="#sec.trust-relationships" id="sec.trust-relationships">Trust Relationships: IdPs, APs, and RPs</a></h1>
<p id="rfc.section.5.6.1.p.1">Any federated identity protocol has three major participants: </p>
<p/>

<dl>
  <dt>Authenticating Party (AP):</dt>
  <dd style="margin-left: 8">The entity which is trying to establish its identity.  </dd>
  <dt></dt>
  <dd style="margin-left: 8"/>
  <dt>Identity Provider (IdP):</dt>
  <dd style="margin-left: 8">The entity which is vouching for the AP's identity.  </dd>
  <dt></dt>
  <dd style="margin-left: 8"/>
  <dt>Relying Party (RP):</dt>
  <dd style="margin-left: 8">The entity which is trying to verify the AP's identity.  </dd>
</dl>

<p> </p>
<p id="rfc.section.5.6.1.p.3">The AP and the IdP have an account relationship of some kind: the AP registers with the IdP and is able to subsequently authenticate directly to the IdP (e.g., with a password). This means that the browser must somehow know which IdP(s) the user has an account relationship with.  This can either be something that the user configures into the browser or that is configured at the calling site and then provided to the PeerConnection by the Web application at the calling site. The use case for having this information configured into the browser is that the user may "log into" the browser to bind it to some identity. This is becoming common in new browsers. However, it should also be possible for the IdP information to simply be provided by the calling application.  </p>
<p id="rfc.section.5.6.1.p.4">At a high level there are two kinds of IdPs: </p>
<p/>

<dl>
  <dt>Authoritative: </dt>
  <dd style="margin-left: 8">IdPs which have verifiable control of some section of the identity space. For instance, in the realm of e-mail, the operator of "example.com" has complete control of the namespace ending in "@example.com". Thus, "alice@example.com" is whoever the operator says it is. Examples of systems with authoritative identity providers include DNSSEC, RFC 4474, and Facebook Connect (Facebook identities only make sense within the context of the Facebook system).  </dd>
  <dt></dt>
  <dd style="margin-left: 8"/>
  <dt>Third-Party: </dt>
  <dd style="margin-left: 8">IdPs which don't have control of their section of the identity space but instead verify user's identities via some unspecified mechanism and then attest to it. Because the IdP doesn't actually control the namespace, RPs need to trust that the IdP is correctly verifying AP identities, and there can potentially be multiple IdPs attesting to the same section of the identity space. Probably the best-known example of a third-party identity provider is SSL certificates, where there are a large number of CAs all of whom can attest to any domain name.  </dd>
</dl>

<p> </p>
<p id="rfc.section.5.6.1.p.6">If an AP is authenticating via an authoritative IdP, then the RP does not need to explicitly configure trust in the IdP at all.  The identity mechanism can directly verify that the IdP indeed made the relevant identity assertion (a function provided by the mechanisms in this document), and any assertion it makes about an identity for which it is authoritative is directly verifiable. Note that this does not mean that the IdP might not lie, but that is a trustworthiness judgement that the user can make at the time he looks at the identity.  </p>
<p id="rfc.section.5.6.1.p.7">By contrast, if an AP is authenticating via a third-party IdP, the RP needs to explicitly trust that IdP (hence the need for an explicit trust anchor list in PKI-based SSL/TLS clients). The list of trustable IdPs needs to be configured directly into the browser, either by the user or potentially by the browser manufacturer. This is a significant advantage of authoritative IdPs and implies that if third-party IdPs are to be supported, the potential number needs to be fairly small.  </p>
<h1 id="rfc.section.5.6.2"><a href="#rfc.section.5.6.2">5.6.2.</a> <a href="#sec.overview" id="sec.overview">Overview of Operation</a></h1>
<p id="rfc.section.5.6.2.p.1">In order to provide security without trusting the calling site, the PeerConnection component of the browser must interact directly with the IdP. The details of the mechanism are described in the W3C API specification, but the general idea is that the PeerConnection component downloads JS from a specific location on the IdP dictated by the IdP domain name. That JS (the "IdP proxy") runs in an isolated security context within the browser and the PeerConnection talks to it via a secure message passing channel.  </p>
<p id="rfc.section.5.6.2.p.2">Note that there are two logically separate functions here: </p>

<ul>
  <li>Identity assertion generation.  </li>
  <li>Identity assertion verification.  </li>
</ul>

<p> </p>
<p id="rfc.section.5.6.2.p.3">The same IdP JS "endpoint" is used for both functions but of course a given IdP might behave differently and load new JS to perform one function or the other.  </p>
<pre>
     +--------------------------------------+
     | Browser                              |
     |                                      |
     | +----------------------------------+ |
     | | https://calling-site.example.com | |
     | |                                  | |
     | |        Calling JS Code           | |
     | |               ^                  | |
     | +---------------|------------------+ |
     |                 | API Calls          |
     |                 v                    |
     |          PeerConnection              |
     |                 ^                    |
     |                 | MessageChannel     |
     |     +-----------|-------------+      |   +---------------+
     |     |           v             |      |   |               |
     |     |       IdP Proxy         |&lt;--------&gt;|   Identity    |
     |     |                         |      |   |   Provider    |
     |     | https://idp.example.org |      |   |               |
     |     +-------------------------+      |   +---------------+
     |                                      |
     +--------------------------------------+
</pre>
<p id="rfc.section.5.6.2.p.4">When the PeerConnection object wants to interact with the IdP, the sequence of events is as follows: </p>

<ol>
  <li>The browser (the PeerConnection component) instantiates an IdP proxy with its source at the IdP. This allows the IdP to load whatever JS is necessary into the proxy, which runs in the IdP's security context.  The browser uses a <a href="#WebMessaging">MessageChannel</a> <cite title="NONE">[WebMessaging]</cite> to interact with the IdP proxy.  </li>
  <li>Once the IdP is ready, the IdP proxy uses the MessageChannel to notify the browser that it is ready.  </li>
  <li>The browser and IdP proxy communicate using the MessageChannel using a standardized message exchange to create or verify identity assertions.  </li>
</ol>

<p> </p>
<p id="rfc.section.5.6.2.p.5">This approach allows us to decouple the browser from any particular identity provider; the browser need only know how to load the IdP's JavaScript--which is deterministic from the IdP's identity--and the generic protocol for requesting and verifying assertions. The IdP provides whatever logic is necessary to bridge the generic protocol to the IdP's specific requirements. Thus, a single browser can support any number of identity protocols, including being forward compatible with IdPs which did not exist at the time the browser was written.  </p>
<h1 id="rfc.section.5.6.3"><a href="#rfc.section.5.6.3">5.6.3.</a> <a href="#sec.standardized" id="sec.standardized">Items for Standardization</a></h1>
<p id="rfc.section.5.6.3.p.1">In order to make this work, we must standardize the following items: </p>
<p/>

<ul>
  <li>The precise information from the signaling message that must be cryptographically bound to the user's identity and a mechanism for carrying assertions in JSEP messages. <a href="#sec.jsep-binding">Section 5.6.4</a> </li>
  <li>The interface to the IdP. <a href="#sec.protocol-details">Section 5.6.5</a> specifies a specific protocol mechanism which allows the use of any identity protocol without requiring specific further protocol support in the browser </li>
  <li>The JavaScript interfaces which the calling application can use to specify the IdP to use to generate assertions and to discover what assertions were received.  </li>
</ul>

<p> </p>
<p id="rfc.section.5.6.3.p.3">The first two items are defined in this document. The final one is defined in the companion W3C WebRTC API specification <a href="#webrtc-api">[webrtc-api]</a>.  </p>
<h1 id="rfc.section.5.6.4"><a href="#rfc.section.5.6.4">5.6.4.</a> <a href="#sec.jsep-binding" id="sec.jsep-binding">Binding Identity Assertions to JSEP Offer/Answer Transactions</a></h1>
<h1 id="rfc.section.5.6.4.1"><a href="#rfc.section.5.6.4.1">5.6.4.1.</a> <a href="#sec.idp-input" id="sec.idp-input">Input to Assertion Generation Process</a></h1>
<p id="rfc.section.5.6.4.1.p.1">An identity assertion binds the user's identity (as asserted by the IdP) to the SDP offer/exchange transaction and specifically to the media. In order to achieve this, the PeerConnection must provide the DTLS-SRTP fingerprint to be bound to the identity. This is provided as a JavaScript object (also known as a dictionary or hash) with a single <samp>fingerprint</samp> key, as shown below: </p>
<pre>
  {
    "fingerprint": [ {
      "algorithm": "sha-256",
      "digest": "4A:AD:B9:B1:3F:...:E5:7C:AB"
    }, {
      "algorithm": "sha-1",
      "digest": "74:E9:76:C8:19:...:F4:45:6B"
    } ]
  }
</pre>
<p id="rfc.section.5.6.4.1.p.2">The <samp>fingerprint</samp> value is an array of objects.  Each object in the array contains <samp>algorithm</samp> and <samp>digest</samp> values, which correspond directly to the algorithm and digest values in the <samp>a=fingerprint</samp> line of the SDP <a href="#RFC4572">[RFC4572]</a>.  </p>
<p id="rfc.section.5.6.4.1.p.3">Note: this structure does not need to be interpreted by the IdP or the IdP proxy. It is consumed solely by the RP's browser.  The IdP merely treats it as an opaque value to be attested to.  Thus, new parameters can be added to the assertion without modifying the IdP.  </p>
<p id="rfc.section.5.6.4.1.p.4">This object is encoded in a <a href="#RFC4627">JSON</a> <cite title="NONE">[RFC4627]</cite> string for passing to the IdP.  </p>
<h1 id="rfc.section.5.6.4.2"><a href="#rfc.section.5.6.4.2">5.6.4.2.</a> Carrying Identity Assertions</h1>
<p id="rfc.section.5.6.4.2.p.1">Once an IdP has generated an assertion, it is attached to the SDP message. This is done by adding a new a-line to the SDP, of the form a=identity. The sole contents of this value are a <a href="#RFC4648">base-64 encoded</a> <cite title="NONE">[RFC4648]</cite> identity assertion.  For example: </p>
<pre>
v=0
o=- 1181923068 1181923196 IN IP4 ua1.example.com
s=example1
c=IN IP4 ua1.example.com
a=fingerprint:sha-1 \
  4A:AD:B9:B1:3F:82:18:3B:54:02:12:DF:3E:5D:49:6B:19:E5:7C:AB
a=identity:\
  eyJpZHAiOnsiZG9tYWluIjoiZXhhbXBsZS5vcmciLCJwcm90b2NvbCI6ImJvZ3Vz\
  In0sImFzc2VydGlvbiI6IntcImlkZW50aXR5XCI6XCJib2JAZXhhbXBsZS5vcmdc\
  IixcImNvbnRlbnRzXCI6XCJhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3l6XCIsXCJz\
  aWduYXR1cmVcIjpcIjAxMDIwMzA0MDUwNlwifSJ9
a=...
t=0 0
m=audio 6056 RTP/SAVP 0
a=sendrecv
...
</pre>
<p id="rfc.section.5.6.4.2.p.2">Each identity attribute should be paired (and attests to) with an <samp>a=fingerprint</samp> attribute and therefore can exist either at the session or media level.  Multiple identity attributes may appear at either level, though it is RECOMMENDED that implementations not do this, because it becomes very unclear what security claim that they are making and the UI guidelines above become unclear.  Browsers MAY choose refuse to display any identity indicators in the face of multiple identity attributes with different identities but SHOULD process multiple attributes with the same identity as described above.  </p>
<p id="rfc.section.5.6.4.2.p.3">Multiple <samp>a=fingerprint</samp> values can be used to offer alternative certificates for a peer.  The <samp>a=identity</samp> attribute MUST include all fingerprint values that are included in <samp>a=fingerprint</samp> lines.  This ensures that the in-use certificate for a DTLS connection is in the set of fingerprints returned from the IdP when verifying an assertion.  This MUST be enforced by an RP by ensuring that all <samp>a=fingerprint</samp> attributes for a given media section are present in the "VERIFY" response (see <a href="#sec.verify-assert">Section 5.6.5.4</a>).  </p>
<h1 id="rfc.section.5.6.4.3"><a href="#rfc.section.5.6.4.3">5.6.4.3.</a> <a href="#sec.a-identity" id="sec.a-identity">a=identity Attribute</a></h1>
<p id="rfc.section.5.6.4.3.p.1">The identity attribute is session level only.  It contains an identity assertion, encoded as a <a href="#RFC4648">base-64 string</a> <cite title="NONE">[RFC4648]</cite>.  </p>
<p>The syntax of this SDP attribute is defined using <a href="#RFC5234">Augmented BNF</a> <cite title="NONE">[RFC5234]</cite>: </p>
<pre>
identity-attribute  = "identity:" identity-assertion
                      [ SP identity-extension
                        *(";" [ SP ] identity-extension) ]
identity-assertion  = base64
base64              = 1*(ALPHA / DIGIT / "+" / "/" / "=" )
identity-extension  = extension-att-name [ "=" extension-att-value ]
extension-att-name  = token
extension-att-value = 1*(%x01-09 / %x0b-0c / %x0e-3a / %x3c-ff)
                      ; byte-string from [RFC4566] omitting ";"
</pre>
<p id="rfc.section.5.6.4.3.p.2">No extensions are defined for this attribute.  </p>
<h1 id="rfc.section.5.6.5"><a href="#rfc.section.5.6.5">5.6.5.</a> <a href="#sec.protocol-details" id="sec.protocol-details">IdP Interaction Details</a></h1>
<h1 id="rfc.section.5.6.5.1"><a href="#rfc.section.5.6.5.1">5.6.5.1.</a> General Message Structure</h1>
<p id="rfc.section.5.6.5.1.p.1">Messages between the PeerConnection object and the IdP proxy are JavaScript objects, shown in examples using JSON <a href="#RFC4627">[RFC4627]</a>.  For instance, the PeerConnection would request a signature with the following "SIGN" message: </p>
<pre>
  {
    "type": "SIGN",
    "id": "1",
    "origin": "https://calling-site.example.com",
    "message": "012345678abcdefghijkl"
  }
</pre>
<p id="rfc.section.5.6.5.1.p.2">All messages MUST contain a <samp>type</samp> field which indicates the general meaning of the message.  </p>
<p id="rfc.section.5.6.5.1.p.3">All requests from the PeerConnection object MUST contain an <samp>id</samp> field which MUST be unique within the scope of the interaction between the browser and the IdP instance. Responses from the IdP proxy MUST contain the same <samp>id</samp> in response, which allows the PeerConnection to correlate requests and responses, in case there are multiple requests/responses outstanding to the same proxy.  </p>
<p id="rfc.section.5.6.5.1.p.4">All requests from the PeerConnection object MUST contain an <samp>origin</samp> field containing the origin of the JS which initiated the PC (i.e., the URL of the calling site).  This origin value can be used by the IdP to make access control decisions. For instance, an IdP might only issue identity assertions for certain calling services in the same way that some IdPs require that relying Web sites have an API key before learning user identity.  </p>
<p id="rfc.section.5.6.5.1.p.5">Any message-specific data is carried in a <samp>message</samp> field.  Depending on the message type, this may either be a string or any JavaScript object that can be conveyed in a message channel.  This includes any object that is able to be serialized to JSON.  </p>
<h1 id="rfc.section.5.6.5.2"><a href="#rfc.section.5.6.5.2">5.6.5.2.</a> Errors</h1>
<p id="rfc.section.5.6.5.2.p.1">If an error occurs, the IdP sends a message of type "ERROR". The message MAY have an "error" field containing freeform text data which containing additional information about what happened. For instance: </p>
<div id="rfc.figure.5"/>
<div id="fig.example-error"/>
<pre>
  {
    "type": "ERROR",
    "id": "1",
    "error": "Signature verification failed"
  }
  </pre>
<p class="figure">Figure 5: Example error</p>
<h1 id="rfc.section.5.6.5.3"><a href="#rfc.section.5.6.5.3">5.6.5.3.</a> <a href="#sec.iframe-setup" id="sec.iframe-setup">IdP Proxy Setup</a></h1>
<p id="rfc.section.5.6.5.3.p.1">In order to perform an identity transaction, the PeerConnection must first create an IdP proxy. While the details of this are specified in the W3C API document, from the perspective of this specification, however, the relevant facts are: </p>
<p/>

<ul>
  <li>The JS runs in the IdP's security context with the base page retrieved from the URL specified in <a href="#sec.idp-uri">Section 5.6.5.3.1</a>.  </li>
  <li>The usual browser sandbox isolation mechanisms MUST be enforced with respect to the IdP proxy.  The IdP cannot be provided with escalated privileges.  </li>
  <li>JS running in the IdP proxy MUST be able to send and receive messages to the PeerConnection and the PC and IdP proxy are able to verify the source and destination of these messages.  </li>
  <li>The IdP proxy is unable to interact with the user.  This includes the creation of popup windows and dialogs.  </li>
</ul>

<p> </p>
<p id="rfc.section.5.6.5.3.p.3">Initially the IdP proxy is in an unready state; the IdP JS must be loaded and there may be several round trips to the IdP server to load and prepare necessary resources.  </p>
<p id="rfc.section.5.6.5.3.p.4">When the IdP proxy is ready to receive commands, it delivers a "READY" message. As this message is unsolicited, it contains only the <samp>type</samp>: </p>
<pre>
  { "type":"READY" }
  </pre>
<p id="rfc.section.5.6.5.3.p.5">Once the PeerConnection object receives the ready message, it can send commands to the IdP proxy.  </p>
<h1 id="rfc.section.5.6.5.3.1"><a href="#rfc.section.5.6.5.3.1">5.6.5.3.1.</a> <a href="#sec.idp-uri" id="sec.idp-uri">Determining the IdP URI</a></h1>
<p id="rfc.section.5.6.5.3.1.p.1">In order to ensure that the IdP is under control of the domain owner rather than someone who merely has an account on the domain owner's server (e.g., in shared hosting scenarios), the IdP JavaScript is hosted at a deterministic location based on the IdP's domain name.  Each IdP proxy instance is associated with two values: </p>
<p/>

<dl>
  <dt>domain name:</dt>
  <dd style="margin-left: 8">The IdP's domain name </dd>
  <dt>protocol:</dt>
  <dd style="margin-left: 8">The specific IdP protocol which the IdP is using. This is a completely opaque IdP-specific string, but allows an IdP to implement two protocols in parallel. This value may be the empty string.  </dd>
</dl>

<p> </p>
<p id="rfc.section.5.6.5.3.1.p.3">Each IdP MUST serve its initial entry page (i.e., the one loaded by the IdP proxy) from a <a href="#RFC5785">well-known URI</a> <cite title="NONE">[RFC5785]</cite>.  The well-known URI for an IdP proxy is formed from the following URI components: </p>

<ol>
  <li>The scheme, "https:".  An IdP MUST be loaded using <a href="#RFC2818">HTTPS</a> <cite title="NONE">[RFC2818]</cite>.  </li>
  <li>The authority, which is the IdP domain name.  The authority MAY contain a non-default port number.  Any port number is removed when determining if an asserted identity matches the name of the IdP.  The authority MUST NOT include a userinfo sub-component.  </li>
  <li>The path, starting with "/.well-known/idp-proxy/" and appended with the IdP protocol.  Note that the separator characters '/' (%2F) and '\' (%5C) MUST NOT be permitted in the protocol field, lest an attacker be able to direct requests outside of the controlled "/.well-known/" prefix.  Query and fragment values MAY be used by including '?' or '#' characters.  </li>
</ol>

<p> For example, for the IdP "identity.example.com" and the protocol "example", the URL would be: </p>
<pre>
  https://example.com/.well-known/idp-proxy/example
  </pre>
<h1 id="rfc.section.5.6.5.3.1.1"><a href="#rfc.section.5.6.5.3.1.1">5.6.5.3.1.1.</a> Authenticating Party</h1>
<p id="rfc.section.5.6.5.3.1.1.p.1">How an AP determines the appropriate IdP domain is out of scope of this specification. In general, however, the AP has some actual account relationship with the IdP, as this identity is what the IdP is attesting to. Thus, the AP somehow supplies the IdP information to the browser. Some potential mechanisms include: </p>

<ul>
  <li>Provided by the user directly.  </li>
  <li>Selected from some set of IdPs known to the calling site.  E.g., a button that shows "Authenticate via Facebook Connect" </li>
</ul>

<p> </p>
<h1 id="rfc.section.5.6.5.3.1.2"><a href="#rfc.section.5.6.5.3.1.2">5.6.5.3.1.2.</a> Relying Party</h1>
<p id="rfc.section.5.6.5.3.1.2.p.1">Unlike the AP, the RP need not have any particular relationship with the IdP. Rather, it needs to be able to process whatever assertion is provided by the AP.  As the assertion contains the IdP's identity, the URI can be constructed directly from the assertion, and thus the RP can directly verify the technical validity of the assertion with no user interaction. Authoritative assertions need only be verifiable. Third-party assertions also MUST be verified against local policy, as described in <a href="#sec.id-format">Section 5.6.5.4.1</a>.  </p>
<h1 id="rfc.section.5.6.5.3.2"><a href="#rfc.section.5.6.5.3.2">5.6.5.3.2.</a> <a href="#sec.request-assert" id="sec.request-assert">Requesting Assertions</a></h1>
<p id="rfc.section.5.6.5.3.2.p.1">In order to request an assertion, the PeerConnection sends a "SIGN" message.  Aside from the mandatory fields, this message has a <samp>message</samp> field containing a string.  The string contains a JSON-encoded object containing certificate fingerprints but are treated as opaque from the perspective of the IdP.  </p>
<p id="rfc.section.5.6.5.3.2.p.2">An application can optionally provide a user identifier when specifying an IdP.  This value is a hint that the IdP can use to select amongst multiple identities, or to avoid providing assertions for unwanted identities.  The user identifier hint is passed to the IdP in a <samp>username</samp> field alongside the <samp>message</samp>.  The <samp>username</samp> is a string that has no meaning to any entity other than the IdP, it can contain any data the IdP needs in order to correctly generate an assertion.  </p>
<p id="rfc.section.5.6.5.3.2.p.3">A successful response to a "SIGN" message contains a <samp>message</samp> field which is a JavaScript dictionary consisting of two fields: </p>
<p/>

<dl>
  <dt>idp:</dt>
  <dd style="margin-left: 8">A dictionary containing the domain name of the provider and the protocol string.  </dd>
  <dt>assertion:</dt>
  <dd style="margin-left: 8">An opaque value containing the assertion itself. This is only interpretable by the IdP or its proxy.  </dd>
</dl>

<p> </p>
<p><a href="#fig.assert-request">Figure 6</a> shows an example transaction, with the message "abcde..." (remember, the messages are opaque at this layer) being signed and bound to identity "ekr@example.org". In this case, the message has presumably been digitally signed/MACed in some way that the IdP can later verify it, but this is an implementation detail and out of scope of this document. Line breaks are inserted solely for readability.  </p>
<div id="rfc.figure.6"/>
<div id="fig.assert-request"/>
<pre>
PeerConnection -&gt; IdP proxy:
  {
    "type": "SIGN",
    "id": "1",
    "origin": "https://calling-service.example.com/",
    "message": "abcdefghijklmnopqrstuvwyz",
    "username": "bob"
  }

IdPProxy -&gt; PeerConnection:
  {
    "type": "SUCCESS",
    "id": "1",
    "message": {
      "idp":{
        "domain": "example.org",
        "protocol": "bogus"
      },
      "assertion": "{\"identity\":\"bob@example.org\",
                     \"contents\":\"abcdefghijklmnopqrstuvwyz\",
                     \"signature\":\"010203040506\"}"
    }
  }
</pre>
<p class="figure">Figure 6: Example assertion request</p>
<p id="rfc.section.5.6.5.3.2.p.6">The <samp>message</samp> structure is serialized into JSON, <a href="#RFC4648">base64-encoded</a> <cite title="NONE">[RFC4648]</cite>, and placed in an <samp>a=identity</samp> attribute.  </p>
<h1 id="rfc.section.5.6.5.3.3"><a href="#rfc.section.5.6.5.3.3">5.6.5.3.3.</a> <a href="#sec.user-login" id="sec.user-login">Managing User Login</a></h1>
<p id="rfc.section.5.6.5.3.3.p.1">In order to generate an identity assertion, the IdP needs proof of the user's identity.  It is common practice to authenticate users (using passwords or multi-factor authentication), then use <a href="#RFC6265">Cookies</a> <cite title="NONE">[RFC6265]</cite> or <a href="#RFC2617">HTTP authentication</a> <cite title="NONE">[RFC2617]</cite> for subsequent exchanges.  </p>
<p id="rfc.section.5.6.5.3.3.p.2">The IdP proxy is able to access cookies, HTTP authentication or other persistent session data because it operates in the security context of the IdP origin.  Therefore, if a user is logged in, the IdP could have all the information needed to generate an assertion.  </p>
<p id="rfc.section.5.6.5.3.3.p.3">An IdP proxy is unable to generate an assertion if the user is not logged in, or the IdP wants to interact with the user to acquire more information before generating the assertion.  If the IdP wants to interact with the user before generating an assertion, the IdP proxy can respond with a "LOGINNEEDED" message.  </p>
<div id="rfc.figure.7"/>
<div id="fig.loginneeded-response"/>
<pre>
IdPProxy -&gt; PeerConnection:
  {
    "type": "LOGINNEEDED",
    "id": "1",
    "error": "...a message explaining the reason for failure...",
    "loginUrl": "https://example.org/login?context=e982606f4fd5"
  }
</pre>
<p class="figure">Figure 7: User interaction needed response</p>
<p id="rfc.section.5.6.5.3.3.p.4">The <samp>loginUrl</samp> field of the "LOGINNEEDED" response contains a URL.  The PeerConnection provides an error event (or similar) to the calling site that includes this URL.  </p>
<p id="rfc.section.5.6.5.3.3.p.5">A calling site is then able to load the provided URL in an IFRAME in order to trigger the required user interactions.  Once any user interactions are complete, the IFRAME MUST send a <a href="#WebMessaging">postMessage</a> <cite title="NONE">[WebMessaging]</cite> to its containing window indicating completion.  Any message is sufficient for this purpose, the <samp>source</samp> parameter identifies the originating IFRAME.  </p>
<p id="rfc.section.5.6.5.3.3.p.6">In all other respects, "LOGINNEEDED" can be treated as an "ERROR" message.  </p>
<h1 id="rfc.section.5.6.5.4"><a href="#rfc.section.5.6.5.4">5.6.5.4.</a> <a href="#sec.verify-assert" id="sec.verify-assert">Verifying Assertions</a></h1>
<p id="rfc.section.5.6.5.4.p.1">In order to verify an assertion, an RP sends a "VERIFY" message to the IdP proxy containing the assertion supplied by the AP in the <samp>message</samp> field.  </p>
<p id="rfc.section.5.6.5.4.p.2">The IdP proxy verifies the assertion. Depending on the identity protocol, the proxy might contact the IdP server or other servers.  For instance, an OAuth-based protocol will likely require using the IdP as an oracle, whereas with BrowserID the IdP proxy can likely verify the signature on the assertion without contacting the IdP, provided that it has cached the IdP's public key.  </p>
<p id="rfc.section.5.6.5.4.p.3">Regardless of the mechanism, if verification succeeds, a successful response from the IdP proxy MUST contain a message field consisting of a object with the following fields: </p>

<dl>
  <dt>identity:</dt>
  <dd style="margin-left: 8">The identity of the AP from the IdP's perspective. Details of this are provided in <a href="#sec.id-format">Section 5.6.5.4.1</a>.  </dd>
  <dt>contents:</dt>
  <dd style="margin-left: 8">The original unmodified string provided by the AP in the original SIGN request.  </dd>
</dl>

<p> </p>
<p><a href="#fig.verify-request">Figure 8</a> shows an example transaction. Line breaks are inserted solely for readability.  </p>
<div id="rfc.figure.8"/>
<div id="fig.verify-request"/>
<pre>
                  
PeerConnection -&gt; IdP Proxy:
  {
    "type": "VERIFY",
    "id": 2,
    "origin": "https://calling-service.example.com/",
    "message": "{\"identity\":\"bob@example.org\",
                 \"contents\":\"abcdefghijklmnopqrstuvwyz\",
                 \"signature\":\"010203040506\"}"
  }

IdP Proxy -&gt; PeerConnection:
  {
    "type": "SUCCESS",
    "id": 2,
    "message": {
      "identity": "bob@example.org",
      "contents": "abcdefghijklmnopqrstuvwyz"
    }
  }
</pre>
<p class="figure">Figure 8: Example verification request</p>
<h1 id="rfc.section.5.6.5.4.1"><a href="#rfc.section.5.6.5.4.1">5.6.5.4.1.</a> <a href="#sec.id-format" id="sec.id-format">Identity Formats</a></h1>
<p id="rfc.section.5.6.5.4.1.p.1">Identities passed from the IdP proxy to the PeerConnection are passed in the <samp>identity</samp> field. This field MUST consist of a string representing the user's identity.  This string is in the form "&lt;user&gt;@&lt;domain&gt;", where <samp>user</samp> consists of any character except '@', and domain is an <a href="#RFC5890">internationalized domain name</a> <cite title="NONE">[RFC5890]</cite>.  </p>
<p id="rfc.section.5.6.5.4.1.p.2">The PeerConnection API MUST check this string as follows: </p>

<ol>
  <li>If the domain portion of the string is equal to the domain name of the IdP proxy, then the assertion is valid, as the IdP is authoritative for this domain.  Comparison of domain names is done using the label equivalence rule defined in Section 2.3.2.4 of <a href="#RFC5890">[RFC5890]</a>.  </li>
  <li>If the domain portion of the string is not equal to the domain name of the IdP proxy, then the PeerConnection object MUST reject the assertion unless: <ol><li>the IdP domain is trusted as an acceptable third-party IdP; and </li><li>local policy is configured to trust this IdP domain for the RHS of the identity string.  </li></ol><p> </p></li>
</ol>

<p> </p>
<p id="rfc.section.5.6.5.4.1.p.3">Sites which have identities that do not fit into the RFC822 style (for instance, identifiers that are simple numeric values, or values that contain '@' characters) SHOULD convert them to this form by escaping illegal characters and appending their IdP domain (e.g., user%40133@identity.example.com), thus ensuring that they are authoritative for the identity.  </p>
<h1 id="rfc.section.6"><a href="#rfc.section.6">6.</a> <a href="#sec.sec-cons" id="sec.sec-cons">Security Considerations</a></h1>
<p id="rfc.section.6.p.1">Much of the security analysis of this problem is contained in <a href="#I-D.ietf-rtcweb-security">[I-D.ietf-rtcweb-security]</a> or in the discussion of the particular issues above. In order to avoid repetition, this section focuses on (a) residual threats that are not addressed by this document and (b) threats produced by failure/misbehavior of one of the components in the system.  </p>
<h1 id="rfc.section.6.1"><a href="#rfc.section.6.1">6.1.</a> Communications Security</h1>
<p id="rfc.section.6.1.p.1">While this document favors DTLS-SRTP, it permits a variety of communications security mechanisms and thus the level of communications security actually provided varies considerably. Any pair of implementations which have multiple security mechanisms in common are subject to being downgraded to the weakest of those common mechanisms by any attacker who can modify the signaling traffic. If communications are over HTTP, this means any on-path attacker. If communications are over HTTPS, this means the signaling server. Implementations which wish to avoid downgrade attack should only offer the strongest available mechanism, which is DTLS/DTLS-SRTP.  Note that the implication of this choice will be that interop to non-DTLS-SRTP devices will need to happen through gateways.  </p>
<p id="rfc.section.6.1.p.2">Even if only DTLS/DTLS-SRTP are used, the signaling server can potentially mount a man-in-the-middle attack unless implementations have some mechanism for independently verifying keys. The UI requirements in <a href="#sec.proposal.comsec">Section 5.5</a> are designed to provide such a mechanism for motivated/security conscious users, but are not suitable for general use.  The identity service mechanisms in <a href="#sec.generic.idp">Section 5.6</a> are more suitable for general use. Note, however, that a malicious signaling service can strip off any such identity assertions, though it cannot forge new ones.  Note that all of the third-party security mechanisms available (whether X.509 certificates or a third-party IdP) rely on the security of the third party--this is of course also true of your connection to the Web site itself. Users who wish to assure themselves of security against a malicious identity provider can only do so by verifying peer credentials directly, e.g., by checking the peer's fingerprint against a value delivered out of band.  </p>
<p id="rfc.section.6.1.p.3">In order to protect against malicious content JavaScript, that JavaScript MUST NOT be allowed to have direct access to---or perform computations with---DTLS keys. For instance, if content JS were able to compute digital signatures, then it would be possible for content JS to get an identity assertion for a browser's generated key and then use that assertion plus a signature by the key to authenticate a call protected under an ephemeral DH key controlled by the content JS, thus violating the security guarantees otherwise provided by the IdP mechanism. Note that it is not sufficient merely to deny the content JS direct access to the keys, as some have suggested doing with the WebCrypto API.  <a href="#webcrypto">[webcrypto]</a>.  The JS must also not be allowed to perform operations that would be valid for a DTLS endpoint. By far the safest approach is simply to deny the ability to perform any operations that depend on secret information associated with the key. Operations that depend on public information, such as exporting the public key are of course safe.  </p>
<h1 id="rfc.section.6.2"><a href="#rfc.section.6.2">6.2.</a> Privacy</h1>
<p id="rfc.section.6.2.p.1">The requirements in this document are intended to allow: </p>
<p/>

<ul>
  <li>Users to participate in calls without revealing their location.  </li>
  <li>Potential callees to avoid revealing their location and even presence status prior to agreeing to answer a call.  </li>
</ul>

<p> </p>
<p id="rfc.section.6.2.p.3">However, these privacy protections come at a performance cost in terms of using TURN relays and, in the latter case, delaying ICE. Sites SHOULD make users aware of these tradeoffs.  </p>
<p id="rfc.section.6.2.p.4">Note that the protections provided here assume a non-malicious calling service. As the calling service always knows the users status and (absent the use of a technology like Tor) their IP address, they can violate the users privacy at will.  Users who wish privacy against the calling sites they are using must use separate privacy enhancing technologies such as Tor. Combined WebRTC/Tor implementations SHOULD arrange to route the media as well as the signaling through Tor. Currently this will produce very suboptimal performance.  </p>
<p id="rfc.section.6.2.p.5">Additionally, any identifier which persists across multiple calls is potentially a problem for privacy, especially for anonymous calling services. Such services SHOULD instruct the browser to use separate DTLS keys for each call and also to use TURN throughout the call. Otherwise, the other side will learn linkable information.  Additionally, browsers SHOULD implement the privacy-preserving CNAME generation mode of <a href="#I-D.ietf-avtcore-6222bis">[I-D.ietf-avtcore-6222bis]</a>.  </p>
<h1 id="rfc.section.6.3"><a href="#rfc.section.6.3">6.3.</a> Denial of Service</h1>
<p id="rfc.section.6.3.p.1">The consent mechanisms described in this document are intended to mitigate denial of service attacks in which an attacker uses clients to send large amounts of traffic to a victim without the consent of the victim. While these mechanisms are sufficient to protect victims who have not implemented WebRTC at all, WebRTC implementations need to be more careful.  </p>
<p id="rfc.section.6.3.p.2">Consider the case of a call center which accepts calls via RTCWeb. An attacker proxies the call center's front-end and arranges for multiple clients to initiate calls to the call center. Note that this requires user consent in many cases but because the data channel does not need consent, he can use that directly. Since ICE will complete, browsers can then be induced to send large amounts of data to the victim call center if it supports the data channel at all. Preventing this attack requires that automated WebRTC implementations implement sensible flow control and have the ability to triage out (i.e., stop responding to ICE probes on) calls which are behaving badly, and especially to be prepared to remotely throttle the data channel in the absence of plausible audio and video (which the attacker cannot control).  </p>
<p id="rfc.section.6.3.p.3">Another related attack is for the signaling service to swap the ICE candidates for the audio and video streams, thus forcing a browser to send video to the sink that the other victim expects will contain audio (perhaps it is only expecting audio!)  potentially causing overload.  Muxing multiple media flows over a single transport makes it harder to individually suppress a single flow by denying ICE keepalives. Either media-level (RTCP) mechanisms must be used or the implementation must deny responses entirely, thus terminating the call.  </p>
<p id="rfc.section.6.3.p.4">Yet another attack, suggested by Magnus Westerlund, is for the attacker to cross-connect offers and answers as follows. It induces the victim to make a call and then uses its control of other users browsers to get them to attempt a call to someone. It then translates their offers into apparent answers to the victim, which looks like large-scale parallel forking.  The victim still responds to ICE responses and now the browsers all try to send media to the victim.  Implementations can defend themselves from this attack by only responding to ICE Binding Requests for a limited number of remote ufrags (this is the reason for the requirement that the JS not be able to control the ufrag and password).  </p>
<p><a href="#I-D.ietf-rtcweb-rtp-usage">[I-D.ietf-rtcweb-rtp-usage]</a> Section 13 documents a number of potential RTCP-based DoS attacks and countermeasures.  </p>
<p id="rfc.section.6.3.p.6">Note that attacks based on confusing one end or the other about consent are possible even in the face of the third-party identity mechanism as long as major parts of the signaling messages are not signed. On the other hand, signing the entire message severely restricts the capabilities of the calling application, so there are difficult tradeoffs here.  </p>
<h1 id="rfc.section.6.4"><a href="#rfc.section.6.4">6.4.</a> IdP Authentication Mechanism</h1>
<p id="rfc.section.6.4.p.1">This mechanism relies for its security on the IdP and on the PeerConnection correctly enforcing the security invariants described above. At a high level, the IdP is attesting that the user identified in the assertion wishes to be associated with the assertion. Thus, it must not be possible for arbitrary third parties to get assertions tied to a user or to produce assertions that RPs will accept.  </p>
<h1 id="rfc.section.6.4.1"><a href="#rfc.section.6.4.1">6.4.1.</a> <a href="#sec.pc-origin" id="sec.pc-origin">PeerConnection Origin Check</a></h1>
<p id="rfc.section.6.4.1.p.1">Fundamentally, the IdP proxy is just a piece of HTML and JS loaded by the browser, so nothing stops a Web attacker o from creating their own IFRAME, loading the IdP proxy HTML/JS, and requesting a signature. In order to prevent this attack, we require that all signatures be tied to a specific origin ("rtcweb://...") which cannot be produced by content JavaScript. Thus, while an attacker can instantiate the IdP proxy, they cannot send messages from an appropriate origin and so cannot create acceptable assertions. I.e., the assertion request must have come from the browser. This origin check is enforced on the relying party side, not on the authenticating party side. The reason for this is to take the burden of knowing which origins are valid off of the IdP, thus making this mechanism extensible to other applications besides WebRTC. The IdP simply needs to gather the origin information (from the posted message) and attach it to the assertion.  </p>
<p id="rfc.section.6.4.1.p.2">Note that although this origin check is enforced on the RP side and not at the IdP, it is absolutely imperative that it be done. The mechanisms in this document rely on the browser enforcing access restrictions on the DTLS keys and assertion requests which do not come with the right origin may be from content JS rather than from browsers, and therefore those access restrictions cannot be assumed.  </p>
<p id="rfc.section.6.4.1.p.3">Note that this check only asserts that the browser (or some other entity with access to the user's authentication data) attests to the request and hence to the fingerprint.  It does not demonstrate that the browser has access to the associated private key. However, attaching one's identity to a key that the user does not control does not appear to provide substantial leverage to an attacker, so a proof of possession is omitted for simplicity.  </p>
<h1 id="rfc.section.6.4.2"><a href="#rfc.section.6.4.2">6.4.2.</a> <a href="#sec.sec-idp-uri" id="sec.sec-idp-uri">IdP Well-known URI</a></h1>
<p id="rfc.section.6.4.2.p.1">As described in <a href="#sec.idp-uri">Section 5.6.5.3.1</a> the IdP proxy HTML/JS landing page is located at a well-known URI based on the IdP's domain name. This requirement prevents an attacker who can write some resources at the IdP (e.g., on one's Facebook wall) from being able to impersonate the IdP.  </p>
<h1 id="rfc.section.6.4.3"><a href="#rfc.section.6.4.3">6.4.3.</a> Privacy of IdP-generated identities and the hosting site</h1>
<p id="rfc.section.6.4.3.p.1">Depending on the structure of the IdP's assertions, the calling site may learn the user's identity from the perspective of the IdP.  In many cases this is not an issue because the user is authenticating to the site via the IdP in any case, for instance when the user has logged in with Facebook Connect and is then authenticating their call with a Facebook identity.  However, in other case, the user may not have already revealed their identity to the site.  In general, IdPs SHOULD either verify that the user is willing to have their identity revealed to the site (e.g., through the usual IdP permissions dialog) or arrange that the identity information is only available to known RPs (e.g., social graph adjacencies) but not to the calling site. The "origin" field of the signature request can be used to check that the user has agreed to disclose their identity to the calling site; because it is supplied by the PeerConnection it can be trusted to be correct.  </p>
<h1 id="rfc.section.6.4.4"><a href="#rfc.section.6.4.4">6.4.4.</a> <a href="#sec.sec-third-party" id="sec.sec-third-party">Security of Third-Party IdPs</a></h1>
<p id="rfc.section.6.4.4.p.1">As discussed above, each third-party IdP represents a new universal trust point and therefore the number of these IdPs needs to be quite limited. Most IdPs, even those which issue unqualified identities such as Facebook, can be recast as authoritative IdPs (e.g., 123456@facebook.com). However, in such cases, the user interface implications are not entirely desirable.  One intermediate approach is to have special (potentially user configurable) UI for large authoritative IdPs, thus allowing the user to instantly grasp that the call is being authenticated by Facebook, Google, etc.  </p>
<h1 id="rfc.section.6.4.5"><a href="#rfc.section.6.4.5">6.4.5.</a> Web Security Feature Interactions</h1>
<p id="rfc.section.6.4.5.p.1">A number of optional Web security features have the potential to cause issues for this mechanism, as discussed below.  </p>
<h1 id="rfc.section.6.4.5.1"><a href="#rfc.section.6.4.5.1">6.4.5.1.</a> <a href="#sec.popup-blocking" id="sec.popup-blocking">Popup Blocking</a></h1>
<p id="rfc.section.6.4.5.1.p.1">The IdP proxy is unable to generate popup windows, dialogs or any other form of user interactions.  This prevents the IdP proxy from being used to circumvent user interaction.  The "LOGINNEEDED" message allows the IdP proxy to inform the calling site of a need for user login, providing the information necessary to satisfy this requirement without resorting to direct user interaction from the IdP proxy itself.  </p>
<h1 id="rfc.section.6.4.5.2"><a href="#rfc.section.6.4.5.2">6.4.5.2.</a> <a href="#sec.3rd-party-cookies" id="sec.3rd-party-cookies">Third Party Cookies</a></h1>
<p id="rfc.section.6.4.5.2.p.1">Some browsers allow users to block third party cookies (cookies associated with origins other than the top level page) for privacy reasons.  Any IdP which uses cookies to persist logins will be broken by third-party cookie blocking. One option is to accept this as a limitation; another is to have the PeerConnection object disable third-party cookie blocking for the IdP proxy.  </p>
<h1 id="rfc.section.7"><a href="#rfc.section.7">7.</a> <a href="#sec.iana-cons" id="sec.iana-cons">IANA Considerations</a></h1>
<p id="rfc.section.7.p.1">This specification defines the <samp>identity</samp> SDP attribute per the procedures of Section 8.2.4 of <a href="#RFC4566">[RFC4566]</a>.  The required information for the registration is included here: </p>

<dl>
  <dt>Contact Name:</dt>
  <dd style="margin-left: 8">Eric Rescorla (ekr@rftm.com)</dd>
  <dt>Attribute Name:</dt>
  <dd style="margin-left: 8">identity</dd>
  <dt>Long Form:</dt>
  <dd style="margin-left: 8">identity</dd>
  <dt>Type of Attribute:</dt>
  <dd style="margin-left: 8">session-level</dd>
  <dt>Charset Considerations:</dt>
  <dd style="margin-left: 8">This attribute is not subject to the charset attribute.</dd>
  <dt>Purpose:</dt>
  <dd style="margin-left: 8">This attribute carries an identity assertion, binding an identity to the transport-level security session.</dd>
  <dt>Appropriate Values:</dt>
  <dd style="margin-left: 8">See <a href="#sec.a-identity">Section 5.6.4.3</a> of RFCXXXX [[Editor Note: This document.</dd>
</dl>

<p> </p>
<h1 id="rfc.section.8"><a href="#rfc.section.8">8.</a> Acknowledgements</h1>
<p id="rfc.section.8.p.1">Bernard Aboba, Harald Alvestrand, Richard Barnes, Dan Druta, Cullen Jennings, Hadriel Kaplan, Matthew Kaufman, Jim McEachern, Martin Thomson, Magnus Westerland.  Matthew Kaufman provided the UI material in <a href="#sec.proposal.comsec">Section 5.5</a>.  </p>
<h1 id="rfc.section.9"><a href="#rfc.section.9">9.</a> Changes</h1>
<h1 id="rfc.section.9.1"><a href="#rfc.section.9.1">9.1.</a> Changes since -06</h1>
<p id="rfc.section.9.1.p.1">Replaced RTCWEB and RTC-Web with WebRTC, except when referring to the IETF WG </p>
<p id="rfc.section.9.1.p.2">Forbade use in mixed content as discussed in Orlando.  </p>
<p id="rfc.section.9.1.p.3">Added a requirement to surface NULL ciphers to the top-level.  </p>
<p id="rfc.section.9.1.p.4">Tried to clarify SRTP versus DTLS-SRTP.  </p>
<p id="rfc.section.9.1.p.5">Added a section on screen sharing permissions.  </p>
<p id="rfc.section.9.1.p.6">Assorted editorial work.  </p>
<h1 id="rfc.section.9.2"><a href="#rfc.section.9.2">9.2.</a> Changes since -05</h1>
<p id="rfc.section.9.2.p.1">The following changes have been made since the -05 draft.  </p>
<p/>

<ul>
  <li>Response to comments from Richard Barnes </li>
  <li>More explanation of the IdP security properties and the federation use case.  </li>
  <li>Editorial cleanup.  </li>
</ul>

<p> </p>
<h1 id="rfc.section.9.3"><a href="#rfc.section.9.3">9.3.</a> Changes since -03</h1>
<p id="rfc.section.9.3.p.1">Version -04 was a version control mistake. Please ignore.  </p>
<p id="rfc.section.9.3.p.2">The following changes have been made since the -04 draft.  </p>
<p/>

<ul>
  <li>Move origin check from IdP to RP per discussion in YVR.  </li>
  <li>Clarified treatment of X.509-level identities.  </li>
  <li>Editorial cleanup.  </li>
</ul>

<p> </p>
<h1 id="rfc.section.9.4"><a href="#rfc.section.9.4">9.4.</a> Changes since -03</h1>
<h1 id="rfc.section.9.5"><a href="#rfc.section.9.5">9.5.</a> Changes since -02</h1>
<p id="rfc.section.9.5.p.1">The following changes have been made since the -02 draft.  </p>
<p/>

<ul>
  <li>Forbid persistent HTTP permissions.  </li>
  <li>Clarified the text in S 5.4 to clearly refer to requirements on the API to provide functionality to the site.  </li>
  <li>Fold in the IETF portion of draft-rescorla-rtcweb-generic-idp </li>
  <li>Retarget the continuing consent section to assume Binding Requests </li>
  <li>Added some more privacy and linkage text in various places.  </li>
  <li>Editorial improvements </li>
</ul>

<p> </p>
<h1 id="rfc.references"><a href="#rfc.references">10.</a> References</h1>
<h1 id="rfc.references.1"><a href="#rfc.references.1">10.1.</a> Normative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="I-D.ietf-avtcore-6222bis">[I-D.ietf-avtcore-6222bis]</b>
      </td>
      <td class="top"><a>Begen, A.</a>, <a>Perkins, C.</a>, <a>Wing, D.</a> and <a>E. Rescorla</a>, "<a href="http://tools.ietf.org/html/draft-ietf-avtcore-6222bis-06">Guidelines for Choosing RTP Control Protocol (RTCP) Canonical Names (CNAMEs)</a>", Internet-Draft draft-ietf-avtcore-6222bis-06, July 2013.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.ietf-rtcweb-rtp-usage">[I-D.ietf-rtcweb-rtp-usage]</b>
      </td>
      <td class="top"><a>Perkins, C.</a>, <a>Westerlund, M.</a> and <a>J. Ott</a>, "<a href="http://tools.ietf.org/html/draft-ietf-rtcweb-rtp-usage-15">Web Real-Time Communication (WebRTC): Media Transport and Use of RTP</a>", Internet-Draft draft-ietf-rtcweb-rtp-usage-15, May 2014.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.ietf-rtcweb-security">[I-D.ietf-rtcweb-security]</b>
      </td>
      <td class="top"><a>Rescorla, E.</a>, "<a href="http://tools.ietf.org/html/draft-ietf-rtcweb-security-06">Security Considerations for WebRTC</a>", Internet-Draft draft-ietf-rtcweb-security-06, January 2014.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.ietf-tsvwg-sctp-dtls-encaps">[I-D.ietf-tsvwg-sctp-dtls-encaps]</b>
      </td>
      <td class="top"><a>Tuexen, M.</a>, <a>Stewart, R.</a>, <a>Jesup, R.</a> and <a>S. Loreto</a>, "<a href="http://tools.ietf.org/html/draft-ietf-tsvwg-sctp-dtls-encaps-04">DTLS Encapsulation of SCTP Packets</a>", Internet-Draft draft-ietf-tsvwg-sctp-dtls-encaps-04, May 2014.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.muthu-behave-consent-freshness">[I-D.muthu-behave-consent-freshness]</b>
      </td>
      <td class="top"><a>Perumal, M.</a>, <a>Wing, D.</a>, <a>R, R.</a> and <a>T. Reddy</a>, "<a href="http://tools.ietf.org/html/draft-muthu-behave-consent-freshness-04">STUN Usage for Consent Freshness</a>", Internet-Draft draft-muthu-behave-consent-freshness-04, July 2013.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC2119">[RFC2119]</b>
      </td>
      <td class="top"><a href="mailto:sob@harvard.edu" title="Harvard University">Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, March 1997.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC2818">[RFC2818]</b>
      </td>
      <td class="top"><a>Rescorla, E.</a>, "<a href="http://tools.ietf.org/html/rfc2818">HTTP Over TLS</a>", RFC 2818, May 2000.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC3711">[RFC3711]</b>
      </td>
      <td class="top"><a>Baugher, M.</a>, <a>McGrew, D.</a>, <a>Naslund, M.</a>, <a>Carrara, E.</a> and <a>K. Norrman</a>, "<a href="http://tools.ietf.org/html/rfc3711">The Secure Real-time Transport Protocol (SRTP)</a>", RFC 3711, March 2004.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4347">[RFC4347]</b>
      </td>
      <td class="top"><a>Rescorla, E.</a> and <a>N. Modadugu</a>, "<a href="http://tools.ietf.org/html/rfc4347">Datagram Transport Layer Security</a>", RFC 4347, April 2006.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4566">[RFC4566]</b>
      </td>
      <td class="top"><a>Handley, M.</a>, <a>Jacobson, V.</a> and <a>C. Perkins</a>, "<a href="http://tools.ietf.org/html/rfc4566">SDP: Session Description Protocol</a>", RFC 4566, July 2006.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4572">[RFC4572]</b>
      </td>
      <td class="top"><a>Lennox, J.</a>, "<a href="http://tools.ietf.org/html/rfc4572">Connection-Oriented Media Transport over the Transport Layer Security (TLS) Protocol in the Session Description Protocol (SDP)</a>", RFC 4572, July 2006.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4627">[RFC4627]</b>
      </td>
      <td class="top"><a>Crockford, D.</a>, "<a href="http://tools.ietf.org/html/rfc4627">The application/json Media Type for JavaScript Object Notation (JSON)</a>", RFC 4627, July 2006.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4648">[RFC4648]</b>
      </td>
      <td class="top"><a>Josefsson, S.</a>, "<a href="http://tools.ietf.org/html/rfc4648">The Base16, Base32, and Base64 Data Encodings</a>", RFC 4648, October 2006.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5234">[RFC5234]</b>
      </td>
      <td class="top"><a>Crocker, D.</a> and <a>P. Overell</a>, "<a href="http://tools.ietf.org/html/rfc5234">Augmented BNF for Syntax Specifications: ABNF</a>", STD 68, RFC 5234, January 2008.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5245">[RFC5245]</b>
      </td>
      <td class="top"><a>Rosenberg, J.</a>, "<a href="http://tools.ietf.org/html/rfc5245">Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols</a>", RFC 5245, April 2010.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5246">[RFC5246]</b>
      </td>
      <td class="top"><a>Dierks, T.</a> and <a>E. Rescorla</a>, "<a href="http://tools.ietf.org/html/rfc5246">The Transport Layer Security (TLS) Protocol Version 1.2</a>", RFC 5246, August 2008.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5763">[RFC5763]</b>
      </td>
      <td class="top"><a>Fischl, J.</a>, <a>Tschofenig, H.</a> and <a>E. Rescorla</a>, "<a href="http://tools.ietf.org/html/rfc5763">Framework for Establishing a Secure Real-time Transport Protocol (SRTP) Security Context Using Datagram Transport Layer Security (DTLS)</a>", RFC 5763, May 2010.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5764">[RFC5764]</b>
      </td>
      <td class="top"><a>McGrew, D.</a> and <a>E. Rescorla</a>, "<a href="http://tools.ietf.org/html/rfc5764">Datagram Transport Layer Security (DTLS) Extension to Establish Keys for the Secure Real-time Transport Protocol (SRTP)</a>", RFC 5764, May 2010.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5785">[RFC5785]</b>
      </td>
      <td class="top"><a>Nottingham, M.</a> and <a>E. Hammer-Lahav</a>, "<a href="http://tools.ietf.org/html/rfc5785">Defining Well-Known Uniform Resource Identifiers (URIs)</a>", RFC 5785, April 2010.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5890">[RFC5890]</b>
      </td>
      <td class="top"><a>Klensin, J.</a>, "<a href="http://tools.ietf.org/html/rfc5890">Internationalized Domain Names for Applications (IDNA): Definitions and Document Framework</a>", RFC 5890, August 2010.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6454">[RFC6454]</b>
      </td>
      <td class="top"><a>Barth, A.</a>, "<a href="http://tools.ietf.org/html/rfc6454">The Web Origin Concept</a>", RFC 6454, December 2011.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="WebMessaging">[WebMessaging]</b>
      </td>
      <td class="top"><a title="W3C">Hickson, </a>, "<a href="http://www.w3.org/TR/2012/CR-webmessaging-20120501/">HTML5 Web Messaging</a>", May 2012.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="webcrypto">[webcrypto]</b>
      </td>
      <td class="top"><a title="W3C">Dahl, Sleevi, </a>, "<a>Web Cryptography API</a>", June 2013.<p>Available at http://www.w3.org/TR/WebCryptoAPI/</p></td>
    </tr>
    <tr>
      <td class="reference">
        <b id="webrtc-api">[webrtc-api]</b>
      </td>
      <td class="top"><a title="W3C">Bergkvist, Burnett, Jennings, Narayanan, </a>, "<a>WebRTC 1.0: Real-time Communication Between Browsers</a>", October 2011.<p>Available at http://dev.w3.org/2011/webrtc/editor/webrtc.html</p></td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.references.2"><a href="#rfc.references.2">10.2.</a> Informative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="I-D.ietf-rtcweb-jsep">[I-D.ietf-rtcweb-jsep]</b>
      </td>
      <td class="top"><a>Uberti, J.</a> and <a>C. Jennings</a>, "<a href="http://tools.ietf.org/html/draft-ietf-rtcweb-jsep-06">Javascript Session Establishment Protocol</a>", Internet-Draft draft-ietf-rtcweb-jsep-06, February 2014.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC2617">[RFC2617]</b>
      </td>
      <td class="top"><a href="mailto:john@math.nwu.edu" title="Northwestern University, Department of Mathematics">Franks, J.</a>, <a href="mailto:pbaker@verisign.com" title="Verisign Inc.">Hallam-Baker, P.</a>, <a href="mailto:jeff@AbiSource.com" title="AbiSource, Inc.">Hostetler, J.</a>, <a href="mailto:lawrence@agranat.com" title="Agranat Systems, Inc.">Lawrence, S.</a>, <a href="mailto:paulle@microsoft.com" title="Microsoft Corporation">Leach, P.</a>, <a title="Netscape Communications Corporation">Luotonen, A.</a> and <a href="mailto:stewart@OpenMarket.com" title="Open Market, Inc.">L. Stewart</a>, "<a href="http://tools.ietf.org/html/rfc2617">HTTP Authentication: Basic and Digest Access Authentication</a>", RFC 2617, June 1999.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC3261">[RFC3261]</b>
      </td>
      <td class="top"><a>Rosenberg, J.</a>, <a>Schulzrinne, H.</a>, <a>Camarillo, G.</a>, <a>Johnston, A.</a>, <a>Peterson, J.</a>, <a>Sparks, R.</a>, <a>Handley, M.</a> and <a>E. Schooler</a>, "<a href="http://tools.ietf.org/html/rfc3261">SIP: Session Initiation Protocol</a>", RFC 3261, June 2002.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5705">[RFC5705]</b>
      </td>
      <td class="top"><a>Rescorla, E.</a>, "<a href="http://tools.ietf.org/html/rfc5705">Keying Material Exporters for Transport Layer Security (TLS)</a>", RFC 5705, March 2010.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6265">[RFC6265]</b>
      </td>
      <td class="top"><a>Barth, A.</a>, "<a href="http://tools.ietf.org/html/rfc6265">HTTP State Management Mechanism</a>", RFC 6265, April 2011.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6455">[RFC6455]</b>
      </td>
      <td class="top"><a>Fette, I.</a> and <a>A. Melnikov</a>, "<a href="http://tools.ietf.org/html/rfc6455">The WebSocket Protocol</a>", RFC 6455, December 2011.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="XmlHttpRequest">[XmlHttpRequest]</b>
      </td>
      <td class="top"><a>van Kesteren, A.</a>, "<a>XMLHttpRequest Level 2</a>", January 2012.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.appendix.A"><a href="#rfc.appendix.A">Appendix A.</a> Example IdP Bindings to Specific Protocols</h1>
<p id="rfc.section.A.p.1">[[TODO: These still need some cleanup.]] </p>
<p id="rfc.section.A.p.2">This section provides some examples of how the mechanisms described in this document could be used with existing authentication protocols such as BrowserID or OAuth. Note that this does not require browser-level support for either protocol.  Rather, the protocols can be fit into the generic framework. (Though BrowserID in particular works better with some client side support).  </p>
<h1 id="rfc.appendix.A.1"><a href="#rfc.appendix.A.1">A.1.</a> BrowserID</h1>
<p id="rfc.section.A.1.p.1">BrowserID [https://browserid.org/] is a technology which allows a user with a verified email address to generate an assertion (authenticated by their identity provider) attesting to their identity (phrased as an email address).  The way that this is used in practice is that the relying party embeds JS in their site which talks to the BrowserID code (either hosted on a trusted intermediary or embedded in the browser). That code generates the assertion which is passed back to the relying party for verification.  The assertion can be verified directly or with a Web service provided by the identity provider.  It's relatively easy to extend this functionality to authenticate WebRTC calls, as shown below.  </p>
<pre>
+----------------------+                     +----------------------+
|                      |                     |                      |
|    Alice's Browser   |                     |     Bob's Browser    |
|                      | OFFER ------------&gt; |                      |
|   Calling JS Code    |                     |    Calling JS Code   |
|          ^           |                     |          ^           |
|          |           |                     |          |           |
|          v           |                     |          v           |
|    PeerConnection    |                     |    PeerConnection    |
|       |      ^       |                     |       |      ^       |
| Finger|      |Signed |                     |Signed |      |       |
| print |      |Finger |                     |Finger |      |"Alice"|
|       |      |print  |                     |print  |      |       |
|       v      |       |                     |       v      |       |
|   +--------------+   |                     |   +---------------+  |
|   |  IdP Proxy   |   |                     |   |  IdP Proxy    |  |
|   |     to       |   |                     |   |     to        |  |
|   |  BrowserID   |   |                     |   |  BrowserID    |  |
|   |  Signer      |   |                     |   |  Verifier     |  |
|   +--------------+   |                     |   +---------------+  |
|           ^          |                     |          ^           |
+-----------|----------+                     +----------|-----------+
            |                                           |
            | Get certificate                           |
            v                                           | Check
+----------------------+                                | certificate
|                      |                                |
|       Identity       |/-------------------------------+
|       Provider       |
|                      |
+----------------------+
</pre>
<p id="rfc.section.A.1.p.2">The way this mechanism works is as follows. On Alice's side, Alice goes to initiate a call.  </p>
<p/>

<ol>
  <li>The calling JS instantiates a PeerConnection and tells it that it is interested in having it authenticated via BrowserID (i.e., it provides "browserid.org" as the IdP name.) </li>
  <li>The PeerConnection instantiates the BrowserID signer in the IdP proxy </li>
  <li>The BrowserID signer contacts Alice's identity provider, authenticating as Alice (likely via a cookie).  </li>
  <li>The identity provider returns a short-term certificate attesting to Alice's identity and her short-term public key.  </li>
  <li>The Browser-ID code signs the fingerprint and returns the signed assertion + certificate to the PeerConnection.  </li>
  <li>The PeerConnection returns the signed information to the calling JS code.  </li>
  <li>The signed assertion gets sent over the wire to Bob's browser (via the signaling service) as part of the call setup.  </li>
</ol>

<p> </p>
<p id="rfc.section.A.1.p.4">The offer might look something like: </p>
<pre>
   {
     "type":"OFFER",
     "sdp":
  "v=0\n
   o=- 2890844526 2890842807 IN IP4 192.0.2.1\n
   s= \n
   c=IN IP4 192.0.2.1\n
   t=2873397496 2873404696\n
   a=fingerprint:SHA-1 ...\n
   4A:AD:B9:B1:3F:82:18:3B:54:02:12:DF:3E:5D:49:6B:19:E5:7C:AB\n
   a=identity [[base-64 encoding of identity assertion:
     {
       "idp":{     // Standardized
         "domain":"browserid.org",
         "method":"default"
       },
       // Assertion contents are browserid-specific
       "assertion": "{
           \"assertion\": {
             \"digest\":\"&lt;hash of the SIGN message&gt;\",
             \"audience\": \"&lt;audience&gt;\"
             \"valid-until\": 1308859352261,
           },
           \"certificate\": {
             \"email\": \"rescorla@example.org\",
             \"public-key\": \"&lt;ekrs-public-key&gt;\",
             \"valid-until\": 1308860561861,
             \"signature\": \"&lt;signature from example.org&gt;\"
           },
           \"content\": \"&lt;content of the SIGN message&gt;\"
       }"
     }
   ]]\n
   m=audio 49170 RTP/AVP 0\n
   ..."
}
</pre>
<p id="rfc.section.A.1.p.5">Note that while the IdP here is specified as "browserid.org", the actual certificate is signed by example.org. This is because BrowserID is a combined authoritative/third-party system in which browserid.org delegates the right to be authoritative (what BrowserID calls primary) to individual domains.  </p>
<p id="rfc.section.A.1.p.6">On Bob's side, he receives the signed assertion as part of the call setup message and a similar procedure happens to verify it.  </p>
<p/>

<ol>
  <li>The calling JS instantiates a PeerConnection and provides it the relevant signaling information, including the signed assertion.  </li>
  <li>The PeerConnection instantiates the IdP proxy which examines the IdP name and brings up the BrowserID verification code.  </li>
  <li>The BrowserID verifier contacts the identity provider to verify the certificate and then uses the key to verify the signed fingerprint.  </li>
  <li>Alice's verified identity is returned to the PeerConnection (it already has the fingerprint).  </li>
  <li>At this point, Bob's browser can display a trusted UI indication that Alice is on the other end of the call.  </li>
</ol>

<p> </p>
<p id="rfc.section.A.1.p.8">When Bob returns his answer, he follows the converse procedure, which provides Alice with a signed assertion of Bob's identity and keying material.  </p>
<h1 id="rfc.appendix.A.2"><a href="#rfc.appendix.A.2">A.2.</a> OAuth</h1>
<p id="rfc.section.A.2.p.1">While OAuth is not directly designed for user-to-user authentication, with a little lateral thinking it can be made to serve. We use the following mapping of OAuth concepts to WebRTC concepts: </p>
<div id="rfc.table.1"/>
<div id="oauth-rtcweb"/>
<table cellpadding="3" cellspacing="0" class="tt full center">
  <thead>
    <tr>
      <th class="left">OAuth</th>
      <th class="left">WebRTC</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="left">Client</td>
      <td class="left">Relying party</td>
    </tr>
    <tr>
      <td class="left">Resource owner</td>
      <td class="left">Authenticating party</td>
    </tr>
    <tr>
      <td class="left">Authorization server</td>
      <td class="left">Identity service</td>
    </tr>
    <tr>
      <td class="left">Resource server</td>
      <td class="left">Identity service</td>
    </tr>
  </tbody>
</table>
<p id="rfc.section.A.2.p.2">The idea here is that when Alice wants to authenticate to Bob (i.e., for Bob to be aware that she is calling). In order to do this, she allows Bob to see a resource on the identity provider that is bound to the call, her identity, and her public key. Then Bob retrieves the resource from the identity provider, thus verifying the binding between Alice and the call.  </p>
<pre>
        Alice                       IdP                       Bob
        ---------------------------------------------------------
        Call-Id, Fingerprint  -------&gt;
        &lt;------------------- Auth Code
        Auth Code ----------------------------------------------&gt;
                                     &lt;----- Get Token + Auth Code
                                     Token ---------------------&gt;
                                     &lt;------------- Get call-info
                                     Call-Id, Fingerprint ------&gt;
</pre>
<p id="rfc.section.A.2.p.3">This is a modified version of a common OAuth flow, but omits the redirects required to have the client point the resource owner to the IdP, which is acting as both the resource server and the authorization server, since Alice already has a handle to the IdP.  </p>
<p id="rfc.section.A.2.p.4">Above, we have referred to "Alice", but really what we mean is the PeerConnection. Specifically, the PeerConnection will instantiate an IFRAME with JS from the IdP and will use that IFRAME to communicate with the IdP, authenticating with Alice's identity (e.g., cookie). Similarly, Bob's PeerConnection instantiates an IFRAME to talk to the IdP.  </p>
<h1 id="rfc.authors">
  <a href="#rfc.authors">Author's Address</a>
</h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Eric Rescorla</span> 
	  <span class="n hidden">
		<span class="family-name">Rescorla</span>
	  </span>
	</span>
	<span class="org vcardline">RTFM, Inc.</span>
	<span class="adr">
	  <span class="vcardline">2064 Edgewood Drive</span>

	  <span class="vcardline">
		<span class="locality">Palo Alto</span>,  
		<span class="region">CA</span> 
		<span class="code">94303</span>
	  </span>
	  <span class="country-name vcardline">USA</span>
	</span>
	<span class="vcardline">Phone: +1 650 678 2350</span>

<span class="vcardline">EMail: <a href="mailto:ekr@rtfm.com">ekr@rtfm.com</a></span>

  </address>
</div>

</body>
</html>
